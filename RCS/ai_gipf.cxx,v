head	1.14;
access;
symbols
	version_1_03:1.14
	version_1_02:1.14
	version_1_01:1.14
	version_1_0_1:1.14
	version_1_0:1.9
	version_0_99_5:1.4
	version_0_99_4:1.3;
locks; strict;
comment	@// @;


1.14
date	99.07.11.15.54.27;	author kurt;	state Exp;
branches;
next	1.13;

1.13
date	99.06.27.08.58.14;	author kurt;	state Exp;
branches;
next	1.12;

1.12
date	99.06.22.18.24.49;	author kurt;	state Exp;
branches;
next	1.11;

1.11
date	99.06.18.20.09.28;	author kurt;	state Exp;
branches;
next	1.10;

1.10
date	99.06.12.08.33.02;	author kurt;	state Exp;
branches;
next	1.9;

1.9
date	99.06.01.16.45.30;	author kurt;	state Exp;
branches;
next	1.8;

1.8
date	99.05.30.10.27.46;	author kurt;	state Exp;
branches;
next	1.7;

1.7
date	99.05.29.11.11.34;	author kurt;	state Exp;
branches;
next	1.6;

1.6
date	99.05.24.20.15.18;	author kurt;	state Exp;
branches;
next	1.5;

1.5
date	99.05.24.18.20.43;	author kurt;	state Exp;
branches;
next	1.4;

1.4
date	99.05.19.16.48.25;	author kurt;	state Exp;
branches;
next	1.3;

1.3
date	99.03.22.19.43.19;	author kurt;	state Exp;
branches;
next	1.2;

1.2
date	99.03.06.19.44.29;	author kurt;	state Exp;
branches;
next	1.1;

1.1
date	99.01.07.17.04.39;	author kurt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@I think I now removed all references to linklist.
All lists are now made with vectors from STL.

+ lots of speed and efficiency improvements
@
text
@/*
** $Id: ai_gipf.cxx,v 1.13 1999/06/27 08:58:14 kurt Exp kurt $
*/
/*
**    Copyright (C) 1998-1999 Kurt Van den Branden
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
*/

#include <string.h>

#include "stream.h"
#include "ai_gipf.h"
#include "configfile.h"
#include "board.h"

#ifdef WINGIPF
extern "C" void checkwindowevents (void);
extern int interrupt_computer;
#endif

#define TIMEDIVIDER 20

/* 84 different possible moves, with gipf-pieces */
fromto newmoves[] = {
	      {"b1","b2",'g'},        {"a1","b2",'g'},	      {"a2","b2",'g'},
	      {"a2","b3",'g'},	      {"a3","b3",'g'},
	      {"a3","b4",'g'},	      {"a4","b4",'g'},
	      {"a4","b5",'g'},	      {"a5","b5",'g'},	      {"b6","b5",'g'},
	      {"b6","c6",'g'},	      {"c7","c6",'g'},
	      {"c7","d7",'g'},	      {"d8","d7",'g'},
	      {"d8","e8",'g'},	      {"e9","e8",'g'},	      {"f8","e8",'g'},
	      {"f8","f7",'g'},	      {"g7","f7",'g'},
	      {"g7","g6",'g'},	      {"h6","g6",'g'},
	      {"h6","h5",'g'},	      {"i5","h5",'g'},	      {"i4","h5",'g'},
	      {"i4","h4",'g'},	      {"i3","h4",'g'},
	      {"i3","h3",'g'},	      {"i2","h3",'g'},
	      {"i2","h2",'g'},	      {"i1","h2",'g'},	      {"h1","h2",'g'},
	      {"h1","g2",'g'},	      {"g1","g2",'g'},
	      {"g1","f2",'g'},	      {"f1","f2",'g'},
	      {"f1","e2",'g'},	      {"e1","e2",'g'},	      {"d1","e2",'g'},
	      {"d1","d2",'g'},	      {"c1","d2",'g'},
	      {"c1","c2",'g'},	      {"b1","c2",'g'},
	      {"b1","b2",'n'},	      {"a1","b2",'n'},	      {"a2","b2",'n'},
	      {"a2","b3",'n'},	      {"a3","b3",'n'},
	      {"a3","b4",'n'},	      {"a4","b4",'n'},
	      {"a4","b5",'n'},	      {"a5","b5",'n'},	      {"b6","b5",'n'},
	      {"b6","c6",'n'},	      {"c7","c6",'n'},
	      {"c7","d7",'n'},	      {"d8","d7",'n'},
	      {"d8","e8",'n'},	      {"e9","e8",'n'},	      {"f8","e8",'n'},
	      {"f8","f7",'n'},	      {"g7","f7",'n'},
	      {"g7","g6",'n'},	      {"h6","g6",'n'},
	      {"h6","h5",'n'},	      {"i5","h5",'n'},	      {"i4","h5",'n'},
	      {"i4","h4",'n'},	      {"i3","h4",'n'},
	      {"i3","h3",'n'},	      {"i2","h3",'n'},
	      {"i2","h2",'n'},	      {"i1","h2",'n'},	      {"h1","h2",'n'},
	      {"h1","g2",'n'},	      {"g1","g2",'n'},
	      {"g1","f2",'n'},	      {"f1","f2",'n'},
	      {"f1","e2",'n'},	      {"e1","e2",'n'},	      {"d1","e2",'n'},
	      {"d1","d2",'n'},	      {"c1","d2",'n'},
	      {"c1","c2",'n'},	      {"b1","c2",'n'}
};

// constructor
ai_gipf::ai_gipf (char playercolour, int gametype)
{
    listheader * configlist;
    int sd,
	md,
	rc;

    movelist = NULL;
    colour = playercolour;
    game = gametype;

    if (colour == 'o')
	maxplayer (PLAYER1);
    else
	maxplayer (PLAYER2);

    /* check for config-values from the config-file */
    configlist = readconfigfile ("gf1.cfg");
    
    sd = findconfigvalue (configlist, "searchdepth", colour, 3);
    searchdepth (sd);
    md = findconfigvalue (configlist, "memorydepth", colour, 2);
    memdepth (md);
    rc = findconfigvalue (configlist, "randomchoose", colour, 1);
    random (rc);

    remoppgipf = findconfigvalue (configlist, "remoppgipf", colour, 0);
    maxgipf = findconfigvalue (configlist, "maxgipf", colour, 3);
    randomfirstmove = findconfigvalue (configlist, "randomfirstmove", 
				       colour, 1);

    clearconfiglist (configlist);

    return;
}


// destructor
ai_gipf::~ai_gipf ()
{
    if (movelist != NULL)
    {
	int len = movelist->size(),
	    i;

	for (i = 0; i < len; i++)
	    delete (*movelist)[i];

	delete movelist;
    }

    return;
}


static struct {
    position coor;
    int value;
} pos_val[] = {
    {{4, 5}, 5}, 
    {{3, 4}, 2},{{3, 5}, 2},{{4, 6}, 2},{{5, 5}, 2},{{5, 4}, 2},{{4, 4}, 2}, 
    {{2, 3}, 1},{{2, 4}, 1},{{2, 5}, 1},{{3, 6}, 1},{{4, 7}, 1},{{5, 6}, 1}, 
    {{6, 5}, 1},{{6, 4}, 1},{{6, 3}, 1},{{5, 3}, 1},{{4, 3}, 1},{{3, 3}, 1}
};

int ai_gipf::evalfunc (void * game, int maxplayer)
{
    board * oboard = (board *) game;
    int total,
	i,
	value;
    double wvalue,
	bvalue;
    char myc,
	otherc,
	piece;
    position * pos;

    myc = (maxplayer == PLAYER1 ? 'o': 'x');
    otherc = b_opponent (myc);

    if (b_game_finished (oboard))
    {
	if (b_winner (oboard) == myc)
	{
	    return (1000);
	}
	else
	{
	    return (-1000);
	}
    }

    /* maybe I can return 1000 or -1000, but I'm not completely sure */
    /*
    ** not sure at all anymore
    ** what if you start with only GIPF-pieces and remove a GIPF
    ** only at the start of your move
    */
    if (b_colour (oboard, myc) == 0)
    {
	return (-999);
    }
    else if (b_colour (oboard, otherc) == 0)
    {
	return (999);
    }

    /* I need to start with a base-value, or I get a lot of 
    ** problems at the start of tournament games */
    wvalue = 20;
    bvalue = 20;

    /* capturing a piece from your opponent is worth 20 points */
    wvalue += 20 * b_black_lost (oboard);
    bvalue += 20 * b_white_lost (oboard);

    /* 1 point for each piece in use on the board */
    if (b_white_gipf (oboard) == -1)
	total = 15;
    else
	total = 18;

    wvalue += total - b_white (oboard) - b_white_lost (oboard);
    bvalue += total - b_black (oboard) - b_black_lost (oboard);

    /* 2 pieces or less left is getting dangerous */

    /* one gipf left can be dangerous, subtract 5 points */
    if (b_white_gipf (oboard) == 1)
    {
	wvalue -= 5;
    }
    if (b_black_gipf (oboard) == 1)
    {
	bvalue -= 5;
    }

    /* pieces closer to the center have a higher value */
    for (i = 0; i < 19; i++)
    {
	pos = &(pos_val[i].coor);
	piece = b_ppiece (oboard, pos);
	if (piece == '.')
	{
	    continue;
	}
	if (piece == 'o')
	{
	    wvalue += pos_val[i].value;
	}
	else if (piece == 'O')
	{
	    wvalue += pos_val[i].value * 1.5;
	}
	else if (piece == 'x')
	{
	    bvalue += pos_val[i].value;
	}
	else
	{
	    bvalue += pos_val[i].value * 1.5;
	}
    }

    /* normalize the result, should be between 1000 and -1000 */
    if (myc == 'o')
    {
	value = (int) ((wvalue - bvalue) * 1000 / (wvalue + bvalue));
    }
    else
    {
	value = (int) ((bvalue - wvalue) * 1000 / (wvalue + bvalue));
    }

    return (value);
}


int ai_gipf::stopfunc (void)
{
    checkwindowevents ();

    if (interrupt_computer)
	return (1);

    return (0);
}


void ai_gipf::listfunc (void * game, vector<basemove *> & movelist)
{
    board * oboard = (board *) game;
#if 0
    listheader * movelist;

    movelist = (listheader *) malloc (sizeof (listheader));
    newlist (movelist);
#endif

    switch (b_status (oboard))
    {
    case S_NORMAL:
    {
	int firstmove,
	    i;
	gipf_move * move;

	if ((b_colour_type (oboard, b_next_piece (oboard)) == 'g') && 
	    (b_colour_gipf (oboard, b_next_piece (oboard)) < maxgipf))
	{
	    firstmove = 0;
	}
	else
	{
	    firstmove = 42;
	}

	for (i = firstmove; i < 84; i++)
	{
	    if ((i > firstmove) && 
		(newmoves[i].to[0] == newmoves[i-1].to[0]) &&
		(newmoves[i].to[1] == newmoves[i-1].to[1]) &&
		(b_piece (oboard, newmoves[i].to) == '.'))
	    {   /*
		** don't add this move, it would have exactly the same
		** result as the previous one
		*/
		continue;
	    }
	    move = new gipf_move;

	    move->type = G_MOVE;
	    move->piece.nr = i;

//	    pushll (movelist, (void *) move);
	    movelist.push_back (move);
	}
	break;
    }

    case S_REMOVEROW:
    {
	listheader * rowlist;
	gipf_move * move;
	rem_row * rowi;
	char * tempstr;
	int counter = 1;

	rowlist = b_row_extra (oboard);
	while ((rowi = (rem_row *) llitembynr (rowlist, counter)) 
	       != NULL)
	{
	    counter++;

	    move = new gipf_move;

	    move->type = G_REMROW;
	    move->remrow.owner = row_owner (rowi);

	    tempstr = postostr (row_start(rowi));
	    move->remrow.from[0] = tempstr[0];
	    move->remrow.from[1] = tempstr[1];
	    move->remrow.from[2] = '\0';
	    free (tempstr);

	    tempstr = postostr (row_end(rowi));
	    move->remrow.to[0] = tempstr[0];
	    move->remrow.to[1] = tempstr[1];
	    move->remrow.to[2] = '\0';
	    free (tempstr);

//	    pushll (movelist, (void *) move);
	    movelist.push_back (move);
	}
	break;
    }

    case S_REMOVEGIPF:
    {
	gipf_move * move;
	rem_gipf * gipfi;
	int mypieces = 0,
	    counter = 1,
	    maxnr,
	    bits1, bits2;
	char * tempstr;

	while ((gipfi = (rem_gipf *) 
		llitembynr (b_gipf_extra (oboard) ,counter)) != NULL)
	{
	    counter++;

	    if (remoppgipf != 0)
	    {
		if (b_otherpiece (b_ppiece (oboard, gipfi->pos)) 
		    == gipfi->owner)
		{
		    mypieces++;
		}
	    }
	    else
	    {
		mypieces++;
	    }
	}

	maxnr = 1 << mypieces; /* 2 ^ mynr */

	for (bits1 = 0; bits1 < maxnr; bits1++)
	{
	    bits2 = bits1;

	    move = new gipf_move;

	    move->type = G_REMGIPF;
	    
//	    move->remgipf.gipflist = 
//		(listheader *) malloc (sizeof (listheader));
//	    newlist (move->remgipf.gipflist);

	    counter = 1;
	    while ((gipfi = (rem_gipf *) 
		    llitembynr (b_gipf_extra (oboard) ,counter)) != NULL)
	    {
		counter++;
		move->remgipf.owner = gipfi->owner;

		tempstr = b_gipf_position (gipfi);
		tempstr = (char *) realloc (tempstr, 4);
		tempstr[2] = 'n';
		tempstr[3] = '\0';
		
		if ((b_otherpiece (b_ppiece (oboard, gipfi->pos)) 
		     == gipfi->owner) || (remoppgipf == 0))
		{
		    if (bits2 & 1)
		    {
			tempstr[2] = 'y';
		    }
		    bits2 = bits2 >> 1;
		}
		else
		{
		    tempstr[2] = 'y';
		}
//		pushll (move->remgipf.gipflist, tempstr);
		move->remgipf.gipflist.push_back (tempstr);
	    }

//	    pushll (movelist, (void *) move);
	    movelist.push_back (move);
	}
	break;
    }

    case S_FINISHED:     // not normal
	break;
    }

    return;
}


void * ai_gipf::newfunc (void * game, basemove * move, int * finished,
			 int * depthdelta, int * nodetype)
{
    board * oboard = (board *) game,
	* nboard;
    gipf_move * gmove = (gipf_move *) move;
    
    switch (gmove->type)
    {
    case G_MOVE:
    {
	char piece;

	piece = b_next_piece (oboard);

	if (newmoves[gmove->piece.nr].type == 'g')
	    piece = b_otherpiece (piece);
	nboard = b_move (oboard, newmoves[gmove->piece.nr].from, 
			 newmoves[gmove->piece.nr].to, piece);

	if (nboard == NULL)
	    return (NULL);

	break;
    }

    case G_REMGIPF:
    {
	rem_gipf * gipfi;
	int counter1 = 1;
//	int counter2;
	board * tboard;
	char * tempstr;
//	char * str;
	vector<char *>::iterator curg, lastg;
	   
	nboard = oboard;
	while ((gipfi = (rem_gipf *) 
		llitembynr (b_gipf_extra (oboard) ,counter1)) != NULL)
	{
	    counter1++;

	    tempstr = b_gipf_position (gipfi);
//	    counter2 = 1;

	    curg = gmove->remgipf.gipflist.begin();
	    lastg = gmove->remgipf.gipflist.end();
	    while (curg != lastg)
//	    while ((str = (char *) 
//		    llitembynr (gmove->remgipf.gipflist, counter2)) != NULL)
	    {
//		counter2++;
		if (((*curg)[0] == tempstr[0]) && ((*curg)[1] == tempstr[1]))
		{
		    if ((*curg)[2] == 'y')
		    {
			tboard = b_remove_gipf (nboard, gipfi);
			if (nboard != oboard)
			    b_del (nboard);
			nboard = tboard;
		    }
		    break;
		}
		curg++;
	    }

	    free (tempstr);
	}

	/* check again for 4 in a row */
	tboard = b_checkfour (nboard);
	if (nboard != oboard)
	{
	    b_del (nboard);
	}
	nboard = tboard;

	break;
    }

    case G_REMROW:
    {
	listheader * rowlist;
	rem_row * rowi;
	char * tempstr;
	int counter = 1;

	rowlist = b_row_extra (oboard);
	while ((rowi = (rem_row *) llitembynr (rowlist, counter)) 
	       != NULL)
	{
	    counter++;

	    tempstr = postostr (rowi->startpos);
	    if ((tempstr[0] != gmove->remrow.from[0]) || 
		(tempstr[1] != gmove->remrow.from[1]))
	    {
		free (tempstr);
		continue;
	    }
	    free (tempstr);

	    tempstr = postostr (rowi->endpos);
	    if ((tempstr[0] != gmove->remrow.to[0]) || 
		(tempstr[1] != gmove->remrow.to[1]))
	    {
		free (tempstr);
		continue;
	    }
	    free (tempstr);

	    break;
	}
	nboard = b_remove_row (oboard, counter - 1);
	break;
    }
    default:
	break;
    }

    switch (b_status (nboard))
    {
    case S_NORMAL:
	*finished = b_game_finished (nboard);
	*depthdelta = 1;

	if (((b_next_piece (nboard) == 'o') && (maxplayer () == PLAYER1)) ||
	    ((b_next_piece (nboard) == 'x') && (maxplayer () == PLAYER2)))
	    *nodetype = MAX;
	else
	    *nodetype = MIN;
	break;

    case S_REMOVEROW:
    {
	listheader * rowlist = b_row_extra (nboard);
	rem_row * rowi = (rem_row *) llitembynr (rowlist, 1);

	*finished = 2;
	*depthdelta = 0;

	if (((row_owner (rowi) == 'o') && (maxplayer () == PLAYER1)) ||
	    ((row_owner (rowi) == 'x') && (maxplayer () == PLAYER2)))
	    *nodetype = MAX;
	else
	    *nodetype = MIN;
	
	break;
    }

    case S_REMOVEGIPF:
    {
	rem_gipf * gipfi = (rem_gipf *)  llitembynr (b_gipf_extra (nboard) ,1);

	*finished = 2;
	*depthdelta = 0;

	if (((b_gipf_owner (gipfi) == 'o') && (maxplayer () == PLAYER1)) ||
	    ((b_gipf_owner (gipfi) == 'x') && (maxplayer () == PLAYER2)))
	    *nodetype = MAX;
	else
	    *nodetype = MIN;
	break;
    }

    case S_FINISHED:     // not normal
	break;
    }


    return ((void *) nboard);
}


#if 0
//void * ai_gipf::copymovefunc (void * move)
gipf_move::gipf_move (gipf_move & tocopy)
{
//    gipf_move * omove = (gipf_move *) move,
//	* nmove;
    int counter;
    char * opos,
    char * npos;

//    nmove = (gipf_move *) malloc (sizeof (gipf_move));

    this->type = tocopy.type;
    switch (this->type)
    {
    case G_MOVE:
	this->piece.nr = tocopy.piece.nr;
	break;
    case G_REMROW:
	this->remrow.from[0] = tocopy.remrow.from[0];
	this->remrow.from[1] = tocopy.remrow.from[1];
	this->remrow.from[2] = '\0';
	this->remrow.to[0] = tocopy.remrow.to[0];
	this->remrow.to[1] = tocopy.remrow.to[1];
	this->remrow.to[2] = '\0';
	this->remrow.owner = tocopy.remrow.owner;
	break;
    case G_REMGIPF:
	this->remgipf.owner = tocopy.remgipf.owner;

	this->remgipf.gipflist = (listheader *) malloc (sizeof (listheader));
	newlist (this->remgipf.gipflist);
	counter = 1;
	while ((opos = (char *) 
		llitembynr (tocopy.remgipf.gipflist, counter)) != NULL)
	{
	    counter++;
	    npos = (char *) malloc (4);
	    npos[0] = opos[0];
	    npos[1] = opos[1];
	    npos[2] = opos[2];
	    npos[3] = '\0';
	    pushll (this->remgipf.gipflist, (void *) npos);
	}
	break;
    }


    return;
}
#endif

basemove * gipf_move::copy (void)
{
    gipf_move * nmove = new gipf_move;
//    int counter;
//    char * opos,
    char * npos;
    vector<char *>::iterator curg, lastg;

    nmove->type = this->type;
    switch (nmove->type)
    {
    case G_MOVE:
	nmove->piece.nr = this->piece.nr;
	break;
    case G_REMROW:
	nmove->remrow.from[0] = this->remrow.from[0];
	nmove->remrow.from[1] = this->remrow.from[1];
	nmove->remrow.from[2] = '\0';
	nmove->remrow.to[0] = this->remrow.to[0];
	nmove->remrow.to[1] = this->remrow.to[1];
	nmove->remrow.to[2] = '\0';
	nmove->remrow.owner = this->remrow.owner;
	break;
    case G_REMGIPF:
	nmove->remgipf.owner = this->remgipf.owner;

	curg = this->remgipf.gipflist.begin();
	lastg = this->remgipf.gipflist.end();
//	nmove->remgipf.gipflist = (listheader *) malloc (sizeof (listheader));
//	newlist (nmove->remgipf.gipflist);
//	counter = 1;
//	while ((opos = (char *) 
//		llitembynr (this->remgipf.gipflist, counter)) != NULL)
	while (curg != lastg)
	{
//	    counter++;
	    npos = (char *) malloc (4);
	    npos[0] = (*curg)[0];
	    npos[1] = (*curg)[1];
	    npos[2] = (*curg)[2];
	    npos[3] = '\0';
//	    pushll (nmove->remgipf.gipflist, (void *) npos);
	    nmove->remgipf.gipflist.push_back(npos);
	    curg++;
	}
	break;
    }

    return (nmove);
}


//void ai_gipf::delmovefunc (void * move)
gipf_move::~gipf_move ()
{
//    char * opos;

    if ((type == G_REMGIPF) && (!remgipf.gipflist.empty()))
    {
//	while ((opos = (char *) 
//		llrembynr (remgipf.gipflist, 1)) != NULL)
//	    free (opos);
//    
//	free (remgipf.gipflist);
	vector<char *>::iterator curg = remgipf.gipflist.begin(),
	    lastg = remgipf.gipflist.end();
	while (curg != lastg)
	{
	    delete (*curg);
	    curg++;
	}
    }

    return;
}


void ai_gipf::delgamefunc (void * game)
{
    board * oboard = (board *) game;

    if (oboard == NULL)
	return;

    b_del (oboard);

    return;
}


void ai_gipf::game_move (board * oboard, float timeleft, 
			 char * type, char * from, char * to)
{
    vector<basemove *> * newmovelist;
    gipf_move * move;
    int savedepth = -1;

    if (movelist != NULL)
    {
	/* 
	** this is probably a problem 
	** signal it and then ignore it
	*/
	cout << "\n WARNING (ai_gipf::game_move):\n";
	cout << "    movelist is not empty!!\n\n";

	int len = movelist->size(),
	    i;

	for (i = 0; i < len; i++)
	    delete (*movelist)[i];

	delete movelist;
	movelist = NULL;
    }

    /*
    ** if this is the first move of the game, reduce memorydepth
    ** to 1, it's not necessary to waste time when there are really
    ** only 2 possible moves
    */
    /* question: should I only do this for tournament games ? */
    if (randomfirstmove && // flag must be one
	(b_move_counter (oboard) == 0) && // first move
	(((b_white_gipf (oboard) == 0) && 
	  (b_white (oboard) == 18) && (b_black (oboard) == 18)) ||
	 ((b_white_gipf (oboard) == 3) && 
	  (b_white (oboard) == 12) && (b_black (oboard) == 12)) ||
	 ((b_white_gipf (oboard) == -1) && 
	  (b_white (oboard) == 12) && (b_black (oboard) == 12))))
    {
	savedepth = searchdepth ();
	searchdepth (1);
    }

    newmovelist = mtdf_id ((void *) oboard, MAX, timeleft/TIMEDIVIDER);

    /* reset the correct searchdepth if necessary */
    if (savedepth != -1)
    {
	searchdepth (savedepth);
    }

    if (newmovelist == NULL)
    {
	// have to check what happened here
	if (status () == AI_STOPPED)
	    return;
    }

    cleanupmovelist (newmovelist);
    movelist = newmovelist;

    // remove the first item from the movelist
    move = (gipf_move *) (*movelist)[0];
    movelist->erase (movelist->begin());
//    move = (gipf_move *) llrembynr (movelist, 1);

    if (movelist->empty())
    {
	delete movelist;
	movelist = NULL;
    }
//    if (llitembynr (movelist, 1) == NULL)
//    {   // delete movelist if empty
//	free (movelist);
//	movelist = NULL;
//    }

    if (move->type != G_MOVE)
    {   // very wrong, what happened here ?
    }
	
    from[0] = newmoves[move->piece.nr].from[0];
    from[1] = newmoves[move->piece.nr].from[1];
    to[0] = newmoves[move->piece.nr].to[0];
    to[1] = newmoves[move->piece.nr].to[1];
    *type = newmoves[move->piece.nr].type;

    delete move;

    return;
}


char ai_gipf::game_gipf (board * oboard, float timeleft, 
			 char * pos)
{
    vector<basemove *> * newmovelist;
    gipf_move * move;
//    char * gipfpos;
    char result;
    int counter;
    vector<char *>::iterator curg,
	lastg;

    if (movelist == NULL)
    {
	newmovelist = mtdf_id ((void *) oboard, MAX, timeleft/TIMEDIVIDER);

	if (newmovelist == NULL)
	{
	    // have to check what happened here
	    if (status () == AI_STOPPED)
		return (' ');
	}
	
	cleanupmovelist (newmovelist);
	movelist = newmovelist;
    }

//    move = (gipf_move *) llitembynr (movelist, 1);
    move = (gipf_move *) (*movelist)[0];
    if ((move == NULL) || (move->type != G_REMGIPF))
    {   // very wrong, what happened here ?
    }

//    counter = 1;
//    while ((gipfpos = (char *) 
//	    llitembynr (move->remgipf.gipflist, counter)) != NULL)
    curg = move->remgipf.gipflist.begin();
    lastg = move->remgipf.gipflist.end();
    while (curg != lastg)
    {
	if (strncmp (*curg, pos, 2) == 0)
	{
	    break;
	}
//	counter++;
	curg++;
    }

//    if (gipfpos == NULL)
    if (curg == lastg)
    {   // very wrong, gipf-position not found
    }

    result = (*curg)[2];
    free (*curg);
    move->remgipf.gipflist.erase (curg);
//    result = gipfpos[2];
//    gipfpos = (char *) llrembynr (move->remgipf.gipflist, counter);
//    free (gipfpos);

//    if (llitembynr (move->remgipf.gipflist, 1) == NULL)
    if (move->remgipf.gipflist.empty())
    {
	delete move;

	movelist->erase (movelist->begin());

	if (movelist->empty())
	{   // delete movelist if empty
	    delete movelist;
	    movelist = NULL;
	}
    }

    return (result);
}


char ai_gipf::game_row (board * oboard, float timeleft, 
			char * start, char * end)
{
    vector<basemove *> * newmovelist;
    gipf_move * move;
    char result = 'n';

    if (movelist == NULL)
    {
	newmovelist = mtdf_id ((void *) oboard, MAX, timeleft/TIMEDIVIDER);

	if (newmovelist == NULL)
	{
	    // have to check what happened here
	    if (status () == AI_STOPPED)
		return (' ');
	}
	
	cleanupmovelist (newmovelist);
	movelist = newmovelist;
    }

    move = (gipf_move *) (*movelist)[0];
//    move = (gipf_move *) llitembynr (movelist, 1);
    if ((move == NULL) || (move->type != G_REMROW))
    {   // very wrong, what happened here ?
    }

    if (strncmp (start, move->remrow.from, 2) == 0)
    {
	if (strncmp (end, move->remrow.to, 2) == 0)
	    result = 'y';
    }
    else if (strncmp (start, move->remrow.to, 2) == 0)
    {
	if (strncmp (end, move->remrow.from, 2) == 0)
	    result = 'y';
    }
    
    if (result == 'y')
    {
	delete move;

	movelist->erase (movelist->begin());

	if (movelist->empty())
	{   // delete movelist if empty
	    delete movelist;
	    movelist = NULL;
	}
    }

    return (result);
}


/*
** cleanup a list of moves as returned by minimax_ab, mtdf or mtdf_id
** keep only the necessary moves.
** this means:
**    - remove G_MOVE if it is not the first item in the list and remove
**      everything after it. (only keep everything for the first move)
**    - remove everything that is not an action for the current player.
*/
void ai_gipf::cleanupmovelist (vector<basemove *> * mlist)
{
    int counter = 1, /* skip the first item */
	len = mlist->size(),
	i;
    gipf_move * moveitem;

    /* look for the first item that can be deleted */
    for (; counter < len; counter++)
//    while ((moveitem = (gipf_move *) llitembynr (mlist, counter)) != NULL)
    {
	moveitem = (gipf_move *) (*mlist)[counter];
	if ((moveitem->type == G_MOVE) ||
	    ((moveitem->type == G_REMGIPF) && 
	     (moveitem->remgipf.owner != colour)) || 
	    ((moveitem->type == G_REMROW) && 
	     (moveitem->remrow.owner != colour)))
	{
	    break;
	}
//	counter++;
    }

    /* delete everything from now on */
    for (i = len - 1; i >= counter; i--)
//    while ((item = (gipf_move *) llrembynr (mlist, counter)) != NULL)
    {
	delete (* mlist)[i];
	mlist->pop_back();
    }

    return;
}


/*
** C-functions for calling from the main program
*/

void * ai_gipf_new (char colour, int game)
{
    ai_gipf * newgame;

    newgame = new ai_gipf (colour, game);

    return ((void *) newgame);
}

void ai_gipf_move (board * oboard, void * self, float timeleft, 
		   char * type, char * from, char * to)
{
    ai_gipf * game = (ai_gipf *) self;

    game->game_move (oboard, timeleft, type, from, to);
    return;
}

char ai_gipf_gipf (board * oboard, void * self, float timeleft, 
		   char * pos)
{
    ai_gipf * game = (ai_gipf *) self;

    return (game->game_gipf (oboard, timeleft, pos));
}

char ai_gipf_row (board * oboard, void * self, float timeleft, 
		  char * start, char * end)
{
    ai_gipf * game = (ai_gipf *) self;

    return (game->game_row (oboard, timeleft, start, end));
}

void ai_gipf_end (void * self)
{
    ai_gipf * delgame = (ai_gipf *) self;

    delete delgame;

    return;
}
@


1.13
log
@replaced the linklist of possible moves with an STL vector
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.12 1999/06/22 18:24:49 kurt Exp kurt $
d105 2
d114 1
a114 1
// desctructor
a116 3
    void * omove;
    
    // delete remaining movelist
d119 2
a120 2
	while ((omove = (gipf_move *) llrembynr (movelist, 1)) != NULL)
	    delete omove;
d122 4
a125 1
	free (movelist);
d394 3
a396 3
	    move->remgipf.gipflist = 
		(listheader *) malloc (sizeof (listheader));
	    newlist (move->remgipf.gipflist);
d423 2
a424 1
		pushll (move->remgipf.gipflist, tempstr);
d470 2
a471 2
	int counter1 = 1,
	    counter2;
d473 3
a475 2
	char * tempstr,
	    * str;
d484 1
a484 1
	    counter2 = 1;
d486 5
a490 2
	    while ((str = (char *) 
		    llitembynr (gmove->remgipf.gipflist, counter2)) != NULL)
d492 2
a493 2
		counter2++;
		if ((str[0] == tempstr[0]) && (str[1] == tempstr[1]))
d495 1
a495 1
		    if (str[2] == 'y')
d504 1
d623 1
a623 1
	* npos;
d670 4
a673 3
    int counter;
    char * opos,
	* npos;
d693 8
a700 5
	nmove->remgipf.gipflist = (listheader *) malloc (sizeof (listheader));
	newlist (nmove->remgipf.gipflist);
	counter = 1;
	while ((opos = (char *) 
		llitembynr (this->remgipf.gipflist, counter)) != NULL)
d702 1
a702 1
	    counter++;
d704 3
a706 3
	    npos[0] = opos[0];
	    npos[1] = opos[1];
	    npos[2] = opos[2];
d708 3
a710 1
	    pushll (nmove->remgipf.gipflist, (void *) npos);
d722 1
a722 1
    char * opos;
d724 1
a724 1
    if ((type == G_REMGIPF) && (remgipf.gipflist != NULL))
d726 12
a737 5
	while ((opos = (char *) 
		llrembynr (remgipf.gipflist, 1)) != NULL)
	    free (opos);
    
	free (remgipf.gipflist);
d760 1
a760 1
    listheader * newmovelist;
d773 7
a779 6
	void * delmove;
	while ((delmove = (gipf_move *) llrembynr (movelist, 1)) != NULL)
	{
	    delete delmove;
	}
	free (movelist);
d788 9
a796 2
    if ((b_move_counter (oboard) == 0) &&
	(b_next_piece (oboard) == 'o'))
d821 7
a827 5
    move = (gipf_move *) llrembynr (movelist, 1);
    
    if (llitembynr (movelist, 1) == NULL)
    {   // delete movelist if empty
	free (movelist);
d830 5
d855 1
a855 1
    listheader * newmovelist;
d857 2
a858 2
    char * gipfpos,
	result;
d860 2
d878 2
a879 1
    move = (gipf_move *) llitembynr (movelist, 1);
d884 6
a889 3
    counter = 1;
    while ((gipfpos = (char *) 
	    llitembynr (move->remgipf.gipflist, counter)) != NULL)
d891 1
a891 1
	if (strncmp (gipfpos, pos, 2) == 0)
d895 2
a896 1
	counter++;
d899 2
a900 1
    if (gipfpos == NULL)
d904 6
a909 3
    result = gipfpos[2];
    gipfpos = (char *) llrembynr (move->remgipf.gipflist, counter);
    free (gipfpos);
d911 2
a912 1
    if (llitembynr (move->remgipf.gipflist, 1) == NULL)
a913 1
	move = (gipf_move *) llrembynr (movelist, 1);
d916 3
a918 1
	if (llitembynr (movelist, 1) == NULL)
d920 1
a920 1
	    free (movelist);
d932 1
a932 1
    listheader * newmovelist;
d951 2
a952 1
    move = (gipf_move *) llitembynr (movelist, 1);
a969 1
	move = (gipf_move *) llrembynr (movelist, 1);
d972 3
a974 1
	if (llitembynr (movelist, 1) == NULL)
d976 1
a976 1
	    free (movelist);
d993 1
a993 1
void ai_gipf::cleanupmovelist (listheader * mlist)
d995 3
a997 1
    int counter = 2; /* skip the first item */
a998 1
    void * item;
d1001 2
a1002 1
    while ((moveitem = (gipf_move *) llitembynr (mlist, counter)) != NULL)
d1004 1
d1013 1
a1013 1
	counter++;
d1017 2
a1018 1
    while ((item = (gipf_move *) llrembynr (mlist, counter)) != NULL)
d1020 2
a1021 1
	delete item;
@


1.12
log
@don't think about the very first move of the game, just choose it almost
at random.
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.11 1999/06/18 20:09:28 kurt Exp kurt $
d120 2
a121 2
	while ((omove = llrembynr (movelist, 1)) != NULL)
	    delmovefunc (omove);
d265 1
a265 1
listheader * ai_gipf::listfunc (void * game)
d268 1
d273 1
d305 1
a305 1
	    move = (gipf_move *) malloc (sizeof (gipf_move));
d310 2
a311 1
	    pushll (movelist, (void *) move);
d330 1
a330 1
	    move = (gipf_move *) malloc (sizeof (gipf_move));
d347 2
a348 1
	    pushll (movelist, (void *) move);
d388 1
a388 1
	    move = (gipf_move *) malloc (sizeof (gipf_move));
d424 2
a425 1
	    pushll (movelist, (void *) move);
d434 1
a434 1
    return (movelist);
d438 1
a438 1
void * ai_gipf::newfunc (void * game, void * move, int * finished,
d607 3
a609 1
void * ai_gipf::copymovefunc (void * move)
d611 2
a612 2
    gipf_move * omove = (gipf_move *) move,
	* nmove;
d617 37
a653 1
    nmove = (gipf_move *) malloc (sizeof (gipf_move));
d655 12
a666 1
    nmove->type = omove->type;
d670 1
a670 1
	nmove->piece.nr = omove->piece.nr;
d673 2
a674 2
	nmove->remrow.from[0] = omove->remrow.from[0];
	nmove->remrow.from[1] = omove->remrow.from[1];
d676 2
a677 2
	nmove->remrow.to[0] = omove->remrow.to[0];
	nmove->remrow.to[1] = omove->remrow.to[1];
d679 1
a679 1
	nmove->remrow.owner = omove->remrow.owner;
d682 1
a682 1
	nmove->remgipf.owner = omove->remgipf.owner;
d688 1
a688 1
		llitembynr (omove->remgipf.gipflist, counter)) != NULL)
d701 1
a701 2

    return ((void *) nmove);
d705 2
a706 1
void ai_gipf::delmovefunc (void * move)
a707 1
    gipf_move * omove = (gipf_move *) move;
d710 1
a710 1
    if ((omove->type == G_REMGIPF) && (omove->remgipf.gipflist != NULL))
d713 1
a713 1
		llrembynr (omove->remgipf.gipflist, 1)) != NULL)
d716 1
a716 1
	free (omove->remgipf.gipflist);
a718 2
    free (omove);

d753 1
a753 1
	while ((delmove = llrembynr (movelist, 1)) != NULL)
d755 1
a755 1
	    delmovefunc (delmove);
d810 1
a810 1
    delmovefunc ((void *) move);
d867 1
a867 1
	delmovefunc ((void *) move);
d921 1
a921 1
	delmovefunc ((void *) move);
d963 1
a963 1
    while ((item = llrembynr (mlist, counter)) != NULL)
d965 1
a965 1
	delmovefunc (item);
@


1.11
log
@made simpler and faster!
instead of checking if the new board is the same after the move, I decide
it now when I make the list of moves.
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.10 1999/06/12 08:33:02 kurt Exp kurt $
d690 1
d710 12
d723 6
@


1.10
log
@performance improvement: the previous board that is kept for comparing
with the next board doesn't have to be copied, a pointer to the original board
can be used
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.9 1999/06/01 16:45:30 kurt Exp kurt $
a35 6
typedef struct {
    board * game;
    board * prevchild;
    int prevnr;
} gamestruct;

d142 1
a142 2
    gamestruct * mgame = (gamestruct *) game;
    board * oboard = mgame->game;
d267 1
a267 2
    gamestruct * mgame = (gamestruct *) game;
    board * oboard = mgame->game;
d293 10
d436 1
a436 3
    gamestruct * mgame = (gamestruct *) game,
	* ngame;
    board * oboard = mgame->game,
a455 17
	if ((mgame->prevnr < gmove->piece.nr) &&
	    ((newmoves[mgame->prevnr].to[0] == 
	      newmoves[gmove->piece.nr].to[0]) && 
	     (newmoves[mgame->prevnr].to[1] == 
	      newmoves[gmove->piece.nr].to[1])) &&
	    (b_compare (nboard, mgame->prevchild) == 0))
	{
	    b_del (nboard);
	    return (NULL);
	}

//	if (mgame->prevchild != NULL)
//	    b_del (mgame->prevchild);
//	mgame->prevchild = b_copy (nboard);
	mgame->prevchild = nboard;
	mgame->prevnr = gmove->piece.nr;

a547 5
    ngame = (gamestruct *) malloc (sizeof (gamestruct));
    ngame->game = nboard;
    ngame->prevchild = NULL;
    ngame->prevnr = 100;

d598 1
a598 1
    return ((void *) ngame);
d674 1
a674 1
    gamestruct * mgame = (gamestruct *) game;
d676 1
a676 1
    if (mgame == NULL)
d679 1
a679 4
    b_del (mgame->game);
//    if (mgame->prevchild != NULL)
//	b_del (mgame->prevchild);
    free (mgame);
a689 1
    gamestruct * ngame;
d709 1
a709 9
    ngame = (gamestruct *) malloc (sizeof (gamestruct));
    ngame->game = oboard;
    ngame->prevchild = NULL;
    ngame->prevnr = -1;

    newmovelist = mtdf_id ((void *) ngame, MAX, timeleft/TIMEDIVIDER);
//    if (ngame->prevchild != NULL)
//	b_del (ngame->prevchild);
    free (ngame);
a753 1
    gamestruct * ngame;
d757 1
a757 10
	ngame = (gamestruct *) malloc (sizeof (gamestruct));
	ngame->game = oboard;
	ngame->prevchild = NULL;
	ngame->prevnr = -1;

	newmovelist = mtdf_id ((void *) ngame, MAX, timeleft/TIMEDIVIDER);

//	if (ngame->prevchild != NULL)
//	    b_del (ngame->prevchild);
	free (ngame);
a815 1
    gamestruct * ngame;
d819 1
a819 10
	ngame = (gamestruct *) malloc (sizeof (gamestruct));
	ngame->game = oboard;
	ngame->prevchild = NULL;
	ngame->prevnr = -1;

	newmovelist = mtdf_id ((void *) ngame, MAX, timeleft/TIMEDIVIDER);

//	if (ngame->prevchild != NULL)
//	    b_del (ngame->prevchild);
	free (ngame);
@


1.9
log
@updates for correct handling of timed games by the computerplayer
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.8 1999/05/30 10:27:46 kurt Exp kurt $
d467 4
a470 3
	if (mgame->prevchild != NULL)
	    b_del (mgame->prevchild);
	mgame->prevchild = b_copy (nboard);
d702 2
a703 2
    if (mgame->prevchild != NULL)
	b_del (mgame->prevchild);
d741 2
a742 2
    if (ngame->prevchild != NULL)
	b_del (ngame->prevchild);
d799 2
a800 2
	if (ngame->prevchild != NULL)
	    b_del (ngame->prevchild);
d871 2
a872 2
	if (ngame->prevchild != NULL)
	    b_del (ngame->prevchild);
@


1.8
log
@WORKS !
but looks to be somewhat slower than the original version
(even using the mtdf algorithm)
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.7 1999/05/29 11:11:34 kurt Exp kurt $
d34 2
d104 1
a104 1
    md = findconfigvalue (configlist, "memorydepth", colour, 3);
d128 1
a128 1
 
d567 1
a567 1
    ngame->prevnr = -1;
d683 1
a683 1
	    
d709 2
a710 1
void ai_gipf::game_move (board * oboard, char * type, char * from, char * to)
d739 1
a739 1
    newmovelist = mtdf ((void *) ngame, MAX);
d747 2
d779 2
a780 1
char ai_gipf::game_gipf (board * oboard, char * pos)
d796 1
a796 1
	newmovelist = mtdf ((void *) ngame, MAX);
d805 2
d853 2
a854 1
char ai_gipf::game_row (board * oboard, char * start, char * end)
d868 1
a868 1
	newmovelist = mtdf ((void *) ngame, MAX);
d877 2
d968 1
a968 1
void ai_gipf_move (board * oboard, void * self, 
d973 1
a973 1
    game->game_move (oboard, type, from, to);
d977 2
a978 1
char ai_gipf_gipf (board * oboard, void * self, char * pos)
d982 1
a982 1
    return (game->game_gipf (oboard, pos));
d985 2
a986 1
char ai_gipf_row (board * oboard, void * self, char * start, char * end)
d990 1
a990 1
    return (game->game_row (oboard, start, end));
@


1.7
log
@almost correct.

still problems when the memory depth is lower then the maximum search depth
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.6 1999/05/24 20:15:18 kurt Exp kurt $
d37 1
a37 1
    char prevto[3];
d40 40
d283 1
a283 2
	fromto * allmoves;
	int maxmoves,
d290 1
a290 2
	    allmoves = allmovesg;
	    maxmoves = 84;
d294 1
a294 2
	    allmoves = allmovesn;
	    maxmoves = 42;
d297 1
a297 1
	for (i = 0; i < maxmoves; i++)
d302 1
a302 8
	    move->from[0] = allmoves[i].from[0];
	    move->from[1] = allmoves[i].from[1];
	    move->from[2] = '\0';
	    move->to[0] = allmoves[i].to[0];
	    move->to[1] = allmoves[i].to[1];
	    move->to[2] = '\0';
	    move->piecetype = allmoves[i].type;
	    move->gipflist = NULL;
d326 1
a326 1
	    move->piecetype = row_owner (rowi);
d329 3
a331 3
	    move->from[0] = tempstr[0];
	    move->from[1] = tempstr[1];
	    move->from[2] = '\0';
d335 3
a337 3
	    move->to[0] = tempstr[0];
	    move->to[1] = tempstr[1];
	    move->to[2] = '\0';
a339 3
	    move->piecetype = ' ';
	    move->gipflist = NULL;

a382 2
	    move->from[0] = '\0';
	    move->to[0] = '\0';
d384 3
a386 2
	    move->gipflist = (listheader *) malloc (sizeof (listheader));
	    newlist (move->gipflist);
d393 1
a393 1
		move->piecetype = gipfi->owner;
d413 1
a413 1
		pushll (move->gipflist, tempstr);
d445 2
a446 1
	if (gmove->piecetype == 'g')
d448 2
a449 1
	nboard = b_move (oboard, gmove->from, gmove->to, piece);
d454 5
a458 3
	if ((mgame->prevchild != NULL) &&
	    ((mgame->prevto[0] == gmove->to[0]) && 
	     (mgame->prevto[1] == gmove->to[1])) &&
d468 1
a468 2
	mgame->prevto[0] = gmove->to[0];
	mgame->prevto[1] = gmove->to[1];
d491 2
a492 2
	    while ((str = (char *) llitembynr (gmove->gipflist, counter2))
		   != NULL)
d536 2
a537 2
	    if ((tempstr[0] != gmove->from[0]) || 
		(tempstr[1] != gmove->from[1]))
d545 2
a546 2
	    if ((tempstr[0] != gmove->to[0]) || 
		(tempstr[1] != gmove->to[1]))
d565 1
a565 3
    ngame->prevto[0] = 0;
    ngame->prevto[1] = 0;
    ngame->prevto[2] = 0;
d632 16
a647 7
    nmove->from[0] = omove->from[0];
    nmove->from[1] = omove->from[1];
    nmove->from[2] = '\0';
    nmove->to[0] = omove->to[0];
    nmove->to[1] = omove->to[1];
    nmove->to[2] = '\0';
    nmove->piecetype = omove->piecetype;
d649 2
a650 4
    if (omove->gipflist != NULL)
    {
	nmove->gipflist = (listheader *) malloc (sizeof (listheader));
	newlist (nmove->gipflist);
d652 2
a653 1
	while ((opos = (char *) llitembynr (omove->gipflist, counter)) != NULL)
d661 1
a661 1
	    pushll (nmove->gipflist, (void *) npos);
d663 1
d665 1
a665 2
    else
	nmove->gipflist = NULL;
d676 1
a676 1
    if (omove->gipflist != NULL)
d678 2
a679 1
	while ((opos = (char *) llrembynr (omove->gipflist, 1)) != NULL)
d682 1
a682 1
	free (omove->gipflist);
d734 1
a734 3
    ngame->prevto[0] = 0;
    ngame->prevto[1] = 0;
    ngame->prevto[2] = 0;
d762 5
a766 5
    from[0] = move->from[0];
    from[1] = move->from[1];
    to[0] = move->to[0];
    to[1] = move->to[1];
    *type = move->piecetype;
d788 1
a788 3
	ngame->prevto[0] = 0;
	ngame->prevto[1] = 0;
	ngame->prevto[2] = 0;
d811 2
a812 1
    while ((gipfpos = (char *) llitembynr (move->gipflist, counter)) != NULL)
d826 1
a826 1
    gipfpos = (char *) llrembynr (move->gipflist, counter);
d829 1
a829 1
    if (llitembynr (move->gipflist, 1) == NULL)
d857 1
a857 3
	ngame->prevto[0] = 0;
	ngame->prevto[1] = 0;
	ngame->prevto[2] = 0;
d879 1
a879 1
    if (strncmp (start, move->from, 2) == 0)
d881 1
a881 1
	if (strncmp (end, move->to, 2) == 0)
d884 1
a884 1
    else if (strncmp (start, move->to, 2) == 0)
d886 1
a886 1
	if (strncmp (end, move->from, 2) == 0)
d924 4
a927 1
	    (moveitem->piecetype != colour))
@


1.6
log
@looks like it's working
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.5 1999/05/24 18:20:43 kurt Exp kurt $
d34 6
d106 2
a107 1
    board * oboard = (board *) game;
d232 2
a233 1
    board * oboard = (board *) game;
d406 3
a408 1
    board * oboard = (board *) game,
d425 16
d533 7
d590 1
a590 1
    return ((void *) nboard);
d655 16
d675 1
d695 12
a706 1
    newmovelist = minimax_ab ((void *) oboard, MAX);
d747 1
d751 13
a763 1
	newmovelist = minimax_ab ((void *) oboard, MAX);
d817 1
d821 13
a833 1
	newmovelist = minimax_ab ((void *) oboard, MAX);
@


1.5
log
@everything implemented, no compiler-errors
(doesn't work at all)
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.4 1999/05/19 16:48:25 kurt Exp kurt $
d41 2
a42 1
    
d439 1
d442 7
a448 4
		    tboard = b_remove_gipf (nboard, gipfi);
		    if (nboard != oboard)
			b_del (nboard);
		    nboard = tboard;
d588 1
a588 1
	    npos = (char *) malloc (3);
d591 2
a592 1
	    npos[2] = '\0';
@


1.4
log
@more changes, still not finished.
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.3 1999/03/22 19:43:19 kurt Exp kurt $
d22 2
d30 1
a30 1
extern void checkwindowevents (void);
d87 1
a87 1
struct {
d359 5
d370 1
a370 2
			tempstr = b_gipf_position (gipfi);
			pushll (move->gipflist, tempstr);
d376 1
a376 2
		    tempstr = b_gipf_position (gipfi);
		    pushll (move->gipflist, tempstr);
d378 1
d517 1
a517 1
	listheader * rowlist = b_row_extra (oboard);
d534 1
a534 1
	rem_gipf * gipfi = (rem_gipf *)  llitembynr (b_gipf_extra (oboard) ,1);
d619 1
d642 1
d648 22
a669 1
...
d675 54
d734 45
d790 1
a790 1
void cleanupmovelist (listheader * mlist)
@


1.3
log
@create functions for calling the ai_gipf-player from GF1
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.2 1999/03/06 19:44:29 kurt Exp kurt $
d5 1
a5 1
**    Copyright (C) 1998 Kurt Van den Branden
d22 1
d285 1
d287 1
a287 1
	    tempstr = postostr (rowi->startpos);
d293 1
a293 1
	    tempstr = postostr (rowi->endpos);
d347 1
a347 1

d356 1
d610 79
d705 4
d713 3
d720 3
@


1.2
log
@compiles without errors with all functions implemented.

but I don't believe for 1 second that this will work !
@
text
@d2 1
a2 1
** $Id: ai_gipf.cxx,v 1.1 1999/01/07 17:04:39 kurt Exp kurt $
d606 35
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
** $Id$
d24 6
d32 1
a32 1
ai_gipf::ai_gipf (char playercolour)
d40 1
d57 1
a57 1
    remoppgipf = findconfigvalue (configlist, "remoppgipf", colour, 1);
d69 2
d72 513
d587 18
@
