head	1.35;
access;
symbols
	version_1_03:1.35
	version_1_02:1.34
	version_1_01:1.33
	version_1_0_1:1.33
	version_1_0:1.33
	version_0_99_5:1.32
	version_0_99_4:1.32
	version_0_99_3:1.29
	version_0_99_2:1.27
	version_0_99_1:1.20;
locks; strict;
comment	@// @;


1.35
date	2000.02.28.20.01.53;	author kurt;	state Exp;
branches;
next	1.34;

1.34
date	2000.01.25.19.18.38;	author kurt;	state Exp;
branches;
next	1.33;

1.33
date	99.06.01.16.47.54;	author kurt;	state Exp;
branches;
next	1.32;

1.32
date	99.01.07.13.56.43;	author kurt;	state Exp;
branches;
next	1.31;

1.31
date	99.01.06.20.28.51;	author kurt;	state Exp;
branches;
next	1.30;

1.30
date	98.12.13.15.46.56;	author kurt;	state Exp;
branches;
next	1.29;

1.29
date	98.11.27.13.37.59;	author kurt;	state Exp;
branches;
next	1.28;

1.28
date	98.11.26.17.57.11;	author kurt;	state Exp;
branches;
next	1.27;

1.27
date	98.11.15.11.59.32;	author kurt;	state Exp;
branches;
next	1.26;

1.26
date	98.11.09.20.32.12;	author kurt;	state Exp;
branches;
next	1.25;

1.25
date	98.11.04.19.19.27;	author kurt;	state Exp;
branches;
next	1.24;

1.24
date	98.11.01.16.27.39;	author kurt;	state Exp;
branches;
next	1.23;

1.23
date	98.11.01.14.08.38;	author kurt;	state Exp;
branches;
next	1.22;

1.22
date	98.11.01.11.27.39;	author kurt;	state Exp;
branches;
next	1.21;

1.21
date	98.11.01.08.58.11;	author kurt;	state Exp;
branches;
next	1.20;

1.20
date	98.10.28.18.29.37;	author kurt;	state Exp;
branches;
next	1.19;

1.19
date	98.10.27.20.37.27;	author kurt;	state Exp;
branches;
next	1.18;

1.18
date	98.10.25.20.12.13;	author kurt;	state Exp;
branches;
next	1.17;

1.17
date	98.10.22.16.59.57;	author kurt;	state Exp;
branches;
next	1.16;

1.16
date	98.10.20.20.07.41;	author kurt;	state Exp;
branches;
next	1.15;

1.15
date	98.10.20.17.44.57;	author kurt;	state Exp;
branches;
next	1.14;

1.14
date	98.10.19.19.43.02;	author kurt;	state Exp;
branches;
next	1.13;

1.13
date	98.10.18.18.02.35;	author kurt;	state Exp;
branches;
next	1.12;

1.12
date	98.10.15.16.35.39;	author kurt;	state Exp;
branches;
next	1.11;

1.11
date	98.10.15.16.31.46;	author kurt;	state Exp;
branches;
next	1.10;

1.10
date	98.10.14.19.27.23;	author kurt;	state Exp;
branches;
next	1.9;

1.9
date	98.10.14.19.12.37;	author kurt;	state Exp;
branches;
next	1.8;

1.8
date	98.10.12.19.14.11;	author kurt;	state Exp;
branches;
next	1.7;

1.7
date	98.10.11.08.57.07;	author kurt;	state Exp;
branches;
next	1.6;

1.6
date	98.09.29.18.03.14;	author kurt;	state Exp;
branches;
next	1.5;

1.5
date	98.09.28.18.29.02;	author kurt;	state Exp;
branches;
next	1.4;

1.4
date	98.09.27.19.19.04;	author kurt;	state Exp;
branches;
next	1.3;

1.3
date	98.09.27.18.40.17;	author kurt;	state Exp;
branches;
next	1.2;

1.2
date	98.09.24.17.43.43;	author kurt;	state Exp;
branches;
next	1.1;

1.1
date	98.09.22.19.19.42;	author kurt;	state Exp;
branches;
next	;


desc
@@


1.35
log
@new filechooser widget
@
text
@/*
** $Id: thegame.cxx,v 1.34 2000/01/25 19:18:38 kurt Exp kurt $
**
** functions and structures for a game of gipf
*/
/*
**    Copyright (C) 1998 Kurt Van den Branden
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
*/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <sys/time.h>
#include <unistd.h>
#include <FL/fl_draw.H>
#include <FL/Fl.H>

#ifdef MSWIN
#include "gettimeofday.h"
#endif

#include "thegame.h"
#include "gipf_ui.H"
#include "board.h"
#include "callbacks.h"
#include "player_info.h"
#include "drawgif.h"
#include "xmlite.h"

char gametype[4][15] = {"basic", "standard", "tournament", "other game"};
char playertype[2][9] = {"human", "computer"};

/*
** show the window for starting a new game
**
** if the user pressed OK, this will return a structure for starting
** a new game
**
** if you give a parameter different from NULL, then the window will be
** initialised from this game, otherwise, defaults are used
*/
gamestruct * show_new (gamestruct * oldgame)
{
    Fl_Window * neww;
    gamestruct * newgame;

    neww = make_newwindow ();

    // initialize values
    if (oldgame != NULL)
    {
	// gametype
	switch (oldgame->game_type)
	{
	case T_BASIC:
	    radio_basic->setonly();
	    break;
	case T_STANDARD:
	    radio_standard->setonly();
	    break;
	case T_TOURNAMENT:
	    radio_tournament->setonly();
	    break;
	}

	// player names
	whiteplayername->value (oldgame->player[0].name);
	blackplayername->value (oldgame->player[1].name);

	// player type
	if (oldgame->player[0].type)
	    radio_wcompu->setonly();
	else
	    radio_whuman->setonly();

	if (oldgame->player[1].type)
	    radio_bcompu->setonly();
	else
	    radio_bhuman->setonly();

	// timed game
	if (oldgame->player[0].fulltime == -1)
	{
	    toggle_timedgame->clear();
	}
	else
	{
	    toggle_timedgame->set();
	    whitetime->value (oldgame->player[0].fulltime / 60);
	    blacktime->value (oldgame->player[1].fulltime / 60);
	}
    }
    else
    {
	radio_tournament->setonly();
	toggle_timedgame->clear();
	radio_whuman->setonly();
	radio_bcompu->setonly();
    }

    // show or hide the time-counters
    if (toggle_timedgame->value())
    {
	whitetime->activate();
	blacktime->activate();
    }
    else
    {
	whitetime->deactivate();
	blacktime->deactivate();
    }

    neww->show();

    while (1)
    {
	Fl::wait();    

	Fl_Widget *x;
	while ((x = Fl::readqueue())) 
	{
	    if (x == toggle_timedgame)
	    {
		if (toggle_timedgame->value())
		{
		    whitetime->activate();
		    blacktime->activate();
		}
		else
		{
		    whitetime->deactivate();
		    blacktime->deactivate();
		}
	    }
	    else if (x == new_ok)
	    {
		newgame = (gamestruct *) malloc (sizeof (gamestruct));
		newgame->state = GAME_GO;
		newgame->movecounter = 0;

		if (radio_whuman->value()) 
		    newgame->player[0].type = 0;
		else
		    newgame->player[0].type = 1;
		if (radio_bhuman->value()) 
		    newgame->player[1].type = 0;
		else
		    newgame->player[1].type = 1;

		strcpy (newgame->player[0].name, whiteplayername->value());
		strcpy (newgame->player[1].name, blackplayername->value());
		
		if (toggle_timedgame->value())
		{
		    newgame->player[0].fulltime = 60 * (int)whitetime->value();
		    newgame->player[0].timer = 
			(float) newgame->player[0].fulltime;
		    newgame->player[1].fulltime = 60 * (int)blacktime->value();
		    newgame->player[1].timer = 
			(float) newgame->player[1].fulltime;
		}
		else
		{
		    newgame->player[0].fulltime = -1; 
		    newgame->player[0].timer = 0.0;
		    newgame->player[1].fulltime = -1; 
		    newgame->player[1].timer = 0.0;
		}

		if (radio_basic->value ()) { newgame->game_type = T_BASIC;}
		else if (radio_standard->value ()) 
		{ newgame->game_type = T_STANDARD;}
		else if (radio_tournament->value ()) 
		{ newgame->game_type = T_TOURNAMENT;}
		else { return (NULL);}

		newgame->boards[0] = b_new (newgame->game_type);
		newgame->boards[1] = NULL;
		newgame->boards[2] = NULL;
		
		// initialize players
		newgame->player[0].self = 
		    (* players[newgame->player[0].type].newfunc)
		    ('o', newgame->game_type);
		newgame->player[1].self = 
		    (* players[newgame->player[1].type].newfunc)
		    ('x', newgame->game_type);

		newgame->movelog = newlog (gametype[newgame->game_type], 
					   newgame->player[0].name, 
					   newgame->player[1].name);

		delete neww;

		setcurrentfilename ("\0");

		return (newgame);
	    }
	    else if (x == new_cancel)
	    {
		delete neww;
		return (NULL);
	    }
	}
    }

    return (NULL);
}


/*
** show the window for starting a game from a gameboard
**
** if the user pressed OK, this will return a structure for starting
** a the game
**
** the parameter is the board to start from
*/
gamestruct * show_start (board * startboard)
{
    Fl_Window * startw;
    gamestruct * newgame;
    board * newboard;

    if ((newboard = verify_board (startboard)) == NULL)
    {
	return (NULL);
    }

    startw = make_startwindow ();

    /* put default settings in window */
    radio_white->setonly ();
    radio_s_whuman->setonly ();
    radio_s_bcompu->setonly ();
    if (newboard->typewhite == 'g')
	toggle_s_whitegipf->set ();
    else
	toggle_s_whitegipf->deactivate ();
    if (newboard->typeblack == 'g')
	toggle_s_blackgipf->set ();
    else
	toggle_s_blackgipf->deactivate ();

    startw->show();

    while (1)
    {
	Fl::wait();    

	Fl_Widget *x;
	while ((x = Fl::readqueue())) 
	{
	    if (x == start_ok)
	    {
		newgame = (gamestruct *) malloc (sizeof (gamestruct));
		newgame->state = GAME_GO;
		newgame->movecounter = 0;

		if (radio_s_whuman->value() != 0) 
		    newgame->player[0].type = 0;
		else  
		    newgame->player[0].type = 1;

		if (radio_s_bhuman->value() != 0) 
		    newgame->player[1].type = 0;
		else  
		    newgame->player[1].type = 1;

		strcpy (newgame->player[0].name, s_whiteplayername->value());
		strcpy (newgame->player[1].name, s_blackplayername->value());
		
		newgame->player[0].fulltime = -1;
		newgame->player[0].timer = 0.0;
		newgame->player[1].fulltime = -1;
		newgame->player[1].timer = 0.0;

		newgame->game_type = T_OTHER;

		if ((newboard->typewhite == 'g') && 
		    (toggle_s_whitegipf->value () == 0))
		    newboard->typewhite = 'n';
		if ((newboard->typeblack == 'g') && 
		    (toggle_s_blackgipf->value () == 0))
		    newboard->typeblack = 'n';

		if (radio_white->value () != 0)
		    newboard->nextpiece = 'o';
		else
		    newboard->nextpiece = 'x';

		newgame->boards[0] = newboard;
		newgame->boards[1] = NULL;
		newgame->boards[2] = NULL;
		
		// initialize players
		newgame->player[0].self = 
		    (* players[newgame->player[0].type].newfunc)
		    ('o', newgame->game_type);
		newgame->player[1].self = 
		    (* players[newgame->player[1].type].newfunc)
		    ('x', newgame->game_type);

		newgame->movelog = newlog (gametype[newgame->game_type], 
					   newgame->player[0].name, 
					   newgame->player[1].name);

		delete (startw);

		setcurrentfilename ("\0");

		return (newgame);
	    }
	    else if (x == start_cancel)
	    {
		b_del (newboard);
		delete (startw);
		return (NULL);
	    }
	}
    }

    return (NULL);
}


/*
** show the window for calculating one move starting from a gameboard
**
** if the user pressed OK, this will return a structure for calculating
** the one move
**
** the parameter is the board to start from
*/
gamestruct * show_onemove (board * startboard, configvalues * conf)
{
    Fl_Window * onemovew;
    gamestruct * newgame;
    board * newboard;
    int newlevel,
	oldlevel;

    if ((newboard = verify_board (startboard)) == NULL)
    {
	return (NULL);
    }

    onemovew = make_onemovewindow ();

    radio_c_white->setonly ();
    c_level3->setonly ();

    onemovew->show();

    while (1)
    {
	Fl::wait();    

	Fl_Widget *x;
	while ((x = Fl::readqueue())) 
	{
	    if (x == one_ok)
	    {
		newgame = (gamestruct *) malloc (sizeof (gamestruct));
		newgame->state = GAME_GO;
		newgame->movecounter = 0;

		if (radio_c_white->value() != 0)
		{
		    newgame->player[0].type = 1;
		    newgame->player[1].type = 0;
		    strcpy (newgame->player[0].name, "Computer");
		    strcpy (newgame->player[1].name, "None");
		    newboard->nextpiece = 'o';
		}
		else  
		{
		    newgame->player[0].type = 0;
		    newgame->player[1].type = 1;
		    strcpy (newgame->player[1].name, "Computer");
		    strcpy (newgame->player[0].name, "None");
		    newboard->nextpiece = 'x';
		}

		newgame->player[0].fulltime = -1;
		newgame->player[0].timer = 0.0;
		newgame->player[1].fulltime = -1;
		newgame->player[1].timer = 0.0;

		newgame->game_type = T_OTHER;

		newgame->boards[0] = newboard;
		newgame->boards[1] = NULL;
		newgame->boards[2] = NULL;
		
		newgame->config = conf;

		// initialize players
		newgame->player[0].self = 
		    (* players[newgame->player[0].type].newfunc)
		    ('o', newgame->game_type);
		newgame->player[1].self = 
		    (* players[newgame->player[1].type].newfunc)
		    ('x', newgame->game_type);

		newgame->movelog = newlog (gametype[newgame->game_type], 
					   newgame->player[0].name, 
					   newgame->player[1].name);

		if      ((c_level1->value ()) != 0) { newlevel = 1; }
		else if ((c_level2->value ()) != 0) { newlevel = 2; }
		else if ((c_level3->value ()) != 0) { newlevel = 3; }
		else if ((c_level4->value ()) != 0) { newlevel = 4; }
		else if ((c_level5->value ()) != 0) { newlevel = 5; }
		else if ((c_level6->value ()) != 0) { newlevel = 6; }
		else if ((c_level7->value ()) != 0) { newlevel = 7; }
		else if ((c_level8->value ()) != 0) { newlevel = 8; }

		oldlevel = conf->searchdepth;
		if (newlevel != oldlevel)
		{
		    conf->searchdepth = newlevel;
		    writeconfig (conf);
		}

		delete (onemovew);

		setcurrentfilename ("\0");

		/* execute the move here */
		gameboard->setboard (newgame->boards[0]);

		setupmove (newgame);

		newgame->state = GAME_STOP;
		changeinterface (INTERFACE_PLAY, newgame);

		if (newlevel != oldlevel)
		{
		    conf->searchdepth = oldlevel;
		    writeconfig (conf);
		}

		return (newgame);
	    }
	    else if (x == one_cancel)
	    {
		b_del (newboard);
		delete (onemovew);
		return (NULL);
	    }
	}
    }

    return (NULL);
}


/* 
** check if a gameboard can be used to start a game from
**
** returns a copy of sboard that is correctly setup
** or NULL if there is a problem
*/
board * verify_board (board * sboard)
{
    board * nboard;
    rem_row * row_ptr;
    int i, j,
	white = 0,
	black = 0;
    position * pos;

    /* check if one of the players has no pieces left */
    if (b_colour (sboard, 'o') == 0)
    {
	gf1_alert ("ERROR: no game possible from this boardsituation, player white has no pieces left.");
	return (NULL);
    }
    if (b_colour (sboard, 'x') == 0)
    {
	gf1_alert ("ERROR: no game possible from this boardsituation, player black has no pieces left.");
	return (NULL);
    }

    /* count pieces on the board */
    pos = new_position ();
    for (i = 1; i < 8; i++)
	for (j = 2; j <= b_colsize (i); j++)
	{
	    posp_col (pos) = i;
	    posp_row (pos) = j;
	    switch (b_ppiece (sboard, pos))
	    {
	    case 'o':
 		white += 1;
		break;
	    case 'O':
 		white += 2;
		break;
	    case 'x':
 		black += 1;
		break;
	    case 'X':
 		black += 2;
		break;
	    }
	}
	   
    /* check if the board is empty */
    if ((white == 0) && (black == 0))
    {
	gf1_alert ("ERROR: no game possible from this boardsituation, the gameboard is empty.");
	return (NULL);
    }

    /* check for four-in-a-row */
    for (i = 0; i < 21; i++)
    {
	if ((row_ptr = b_rowoffour (sboard, i)) != NULL)
	{
	    del_rem_row ((void *) row_ptr);
	    gf1_alert ("ERROR: no game possible from this boardsituation, four-in-a-row found.");
	    return (NULL);
	}
    }

    /* check if this is a basic game */
    if ((b_colour_gipf (sboard, 'o') == 0) &&
	(b_colour_gipf (sboard, 'x') == 0))
    {
	nboard = b_copy (sboard);
	nboard->gipfwhite = -1;
	nboard->gipfblack = -1;
	nboard->typewhite = 'n';
	nboard->typeblack = 'n';

	/* turn this into a real basic game (if possible) */
	if ((b_colour (nboard, 'o') > 3) && (b_colour (sboard, 'x') > 3))
	{
	    nboard->white -= 3;
	    nboard->black -= 3;
	}

	return (nboard);
    }

    /* tournament or standard game, for me it's always tournament */

    /* 
    ** something is wrong when a player has normal pieces, but
    ** no gipf-pieces
    */
    /* check if one of the player has single pieces, but no gipf-pieces */
    if ((b_colour_gipf (sboard, 'o') == 0) && (b_colour (sboard, 'o') < 18))
    {
	gf1_alert ("ERROR: no game possible from this boardsituation, player white has no gipf-pieces.");
	return (0);
    }
    if ((b_colour_gipf (sboard, 'x') == 0) && (b_colour (sboard, 'x') < 18))
    {
	gf1_alert ("ERROR: no game possible from this boardsituation, player black has no gipf-pieces.");
	return (0);
    }

    nboard = b_copy (sboard);
    nboard->typewhite = 'n';
    nboard->typeblack = 'n';
    if ((18 - b_colour_gipf (sboard, 'o') * 2) == b_colour (sboard, 'o'))
    {   /* only gipf-pieces, allow player to add more */
	nboard->typewhite = 'g';
    }
    if ((18 - b_colour_gipf (sboard, 'x') * 2) == b_colour (sboard, 'x'))
    {   /* only gipf-pieces, allow player to add more */
	nboard->typeblack = 'g';
    }
/*
** I don't check here if the players have 18 pieces
** which means that it's not completely correct
*/

    return (nboard);
}


void delete_game (gamestruct * gameptr)
{
    int i;

    if (gameptr == NULL)
	return;

    /* ask the player to cleanup its data */
    if (gameptr->player[0].self != NULL)
    {
	(* players[gameptr->player[0].type].endfunc) (gameptr->player[0].self);
    }
    if (gameptr->player[1].self != NULL)
    {
	(* players[gameptr->player[1].type].endfunc) (gameptr->player[1].self);
    }

    for (i = 0; i < 3; i++)
    {
	b_del (gameptr->boards[i]);
    }

    deletelog (gameptr->movelog);
    return;
}


/* 
** REMARK: this is the old version
**
** load a game from a file
**
** return NULL if nothing loaded
*/
gamestruct * oldloadgame (char * filename)
{
    char buffer[100],
	tempstr[100];
    FILE * fp;
    int i,
	tempnr;
    gamestruct * newgame;

    if ((fp = fopen (filename, "r")) == NULL)
    {
	gf1_alert (" ERROR: Can't open the file");
	return (NULL);
    }

    newgame = (gamestruct *) malloc (sizeof (gamestruct));
    newgame->state = GAME_GO;

    fgets (buffer, 100, fp);
    if (strncmp (buffer, "# saved game for gf1", 20) != 0)
    {
	gf1_alert (" ERROR: wrong inputfile format");
	free (newgame);
	return (NULL);
    }

    fgets (buffer, 100, fp);
    if (sscanf (buffer, "# gametype: %d", &(newgame->game_type)) != 1)
    {
	gf1_alert (" ERROR: wrong inputfile format");
	free (newgame);
	return (NULL);
    }

    for (i = 0; i < 2; i++)
    {
	fgets (buffer, 100, fp);
	if (sscanf (buffer, "# player%d type: %d", 
		    &tempnr, &(newgame->player[i].type)) != 2)
	{
	    gf1_alert (" ERROR: wrong inputfile format");
	    free (newgame);
	    return (NULL);
	}

	fgets (buffer, 100, fp);
	sprintf (tempstr, "# player%d name: ", i);
	if (strncmp (buffer, tempstr, 16) != 0)
	{
	    gf1_alert (" ERROR: wrong inputfile format");
	    free (newgame);
	    return (NULL);
	}
	buffer[strlen(buffer) - 1] = '\0';
	strcpy (newgame->player[i].name, buffer+16);

	fgets (buffer, 100, fp);
	if (sscanf (buffer, "# player%d fulltime: %d", 
		    &tempnr, &(newgame->player[i].fulltime)) != 2)
	{
	    gf1_alert (" ERROR: wrong inputfile format");
	    free (newgame);
	    return (NULL);
	}

	fgets (buffer, 100, fp);
	if (sscanf (buffer, "# player%d timer: %f", 
		    &tempnr, &(newgame->player[i].timer)) != 2)
	{
	    gf1_alert (" ERROR: wrong inputfile format");
	    free (newgame);
	    return (NULL);
	}

	newgame->player[i].self = NULL;
    }

    fgets (buffer, 100, fp);
    if ((newgame->boards[0] = b_from_file (fp)) == NULL)
    {
	gf1_alert (" ERROR: wrong inputfile format");
	free (newgame);
	return (NULL);
    }
    newgame->boards[1] = NULL;
    newgame->boards[2] = NULL;

    fgets (buffer, 100, fp);
    if ((newgame->movelog = logfromfile (fp)) == NULL)
    {
	gf1_alert (" ERROR: wrong inputfile format");
	free (newgame);
	return (NULL);
    }
    newgame->movecounter = loglength (newgame->movelog);

    fclose (fp);

    // reading was succesfull, init the players
    newgame->player[0].self = 
	(* players[newgame->player[0].type].newfunc) ('o', newgame->game_type);
    newgame->player[1].self = 
	(* players[newgame->player[1].type].newfunc) ('x', newgame->game_type);

    return (newgame);
}


/* 
** load a game from a file
**
** return NULL if nothing loaded
*/
gamestruct * loadgame (void)
{
    char * filename,
	buffer[100],
	tempstr[100];
    FILE * fp;
    int i;
    gamestruct * newgame;
    xmlite_entity * root, *x1;
    xmlite_parser * theparser;

    // ask for filename
    if ((filename = file_chooser ("load game", "*.gf1", NULL)) == NULL)
    {
	return (NULL);
    }

    if ((fp = fopen (filename, "r")) == NULL)
    {
	gf1_alert (" ERROR: Can't open the file");
	return (NULL);
    }

    fgets (buffer, 100, fp);
    fclose (fp);
    if (strncmp (buffer, "# saved game for gf1", 20) == 0)
    {   // old saveformat
	return (oldloadgame (filename));
    }

    theparser = new xmlite_parser (filename);
    root = theparser->parse ();
    delete (theparser);
    if (root == NULL)
    {
	delete (root);
	gf1_alert (" ERROR: Can't parse savefile");
	return (NULL);
    }

    if (root->getname() != "gipfgame")
    {
	delete (root);
	gf1_alert (" ERROR: Not a savefile from gf1");
	return (NULL);
    }

    if (atoi (root->getattribute("formatversion").c_str()) > 1)
    {
	delete (root);
	gf1_alert (" ERROR: Don't know how to handle this fileversion");
	return (NULL);
    }

    newgame = (gamestruct *) malloc (sizeof (gamestruct));
    newgame->state = GAME_GO;

    // gametype
    strcpy (tempstr, root->getattribute("type").c_str());
    newgame->game_type = 3; // put some default value in
    for (i = 0; i < 4; i++)
    {
	if (strcmp (tempstr, gametype[i]) == 0)
	{
	    newgame->game_type = i;
	    break;
	}
    }

    // players
    x1 = root->getcontentbyname ("whiteplayer");
    strcpy (newgame->player[0].name, x1->getvalue().c_str());
    newgame->player[0].type = x1->getattribute ("type") == "human" ? 0 : 1;
    newgame->player[0].fulltime = atoi (x1->getattribute ("fulltime").c_str());
    newgame->player[0].timer = atof (x1->getattribute ("timeleft").c_str());
    newgame->player[0].self = NULL;
    x1 = root->getcontentbyname ("blackplayer");
    strcpy (newgame->player[1].name, x1->getvalue().c_str());
    newgame->player[1].type = x1->getattribute ("type") == "human" ? 0 : 1;
    newgame->player[1].fulltime = atoi (x1->getattribute ("fulltime").c_str());
    newgame->player[1].timer = atof (x1->getattribute ("timeleft").c_str());
    newgame->player[1].self = NULL;

    // the boardsituation
    newgame->boards[0] = b_from_xml (root->getcontentbyname ("board"));
    newgame->boards[1] = NULL;
    newgame->boards[2] = NULL;

    // the log of moves
    newgame->movelog = logfromxml (root->getcontentbyname ("gamelog"));
    newgame->movecounter = loglength (newgame->movelog);

    // reading was succesfull, init the players
    newgame->player[0].self = 
	(* players[newgame->player[0].type].newfunc) ('o', newgame->game_type);
    newgame->player[1].self = 
	(* players[newgame->player[1].type].newfunc) ('x', newgame->game_type);

    delete (root);

    setcurrentfilename (filename);

    return (newgame);
}


/* 
** save a game to a file
*/
void savegame (gamestruct * gameptr)
{
    char * filename;
    xmlite_entity *x1, *x2;
    char tempstr[100],
	* cfile;

    if (gameptr == NULL)
    {
	gf1_alert (" no current game to be saved");
	return;
    }

    // ask for filename
    cfile = getcurrentfilename ();
    if (cfile[0] == '\0')
	strcpy (tempstr, "./savegame.gf1");
    else
	strcpy (tempstr, cfile);
    if ((filename = file_chooser ("save game", "*.gf1", tempstr)) 
	== NULL)
    {
	return;
    }

    // gipfgame
    x1 = new xmlite_entity ("gipfgame");
    x1->addattribute ("type", gametype[gameptr->game_type]);
    x1->addattribute ("formatversion", "1");

    // white player
    x2 = new xmlite_entity ("whiteplayer");
    sprintf (tempstr, "%f", gameptr->player[0].timer);
    x2->addattribute ("timeleft", tempstr);
    sprintf (tempstr, "%d", gameptr->player[0].fulltime);
    x2->addattribute ("fulltime", tempstr);
    x2->addattribute ("type", playertype[gameptr->player[0].type]);
    x2->setvalue (gameptr->player[0].name);
    x1->addcontent (x2);

    // black player
    x2 = new xmlite_entity ("blackplayer");
    sprintf (tempstr, "%f", gameptr->player[1].timer);
    x2->addattribute ("timeleft", tempstr);
    sprintf (tempstr, "%d", gameptr->player[1].fulltime);
    x2->addattribute ("fulltime", tempstr);
    x2->addattribute ("type", playertype[gameptr->player[1].type]);
    x2->setvalue (gameptr->player[1].name);
    x1->addcontent (x2);

    // last gameboard
    x2 = b_to_xml (gameptr->boards[0]);
    x1->addcontent (x2);

    // gamelog
    x2 = logtoxml (gameptr->movelog);
    x1->addcontent (x2);

    x1->writetofile (filename);
    delete (x1);

    setcurrentfilename (filename);

    return;
}


void setupmove (gamestruct * thegame)
{
    char tempstr[100],
	nextpiece,
	winner = ' ';

    if ((thegame == NULL) || (thegame->state == GAME_STOP))
    {
	changeinterface (INTERFACE_PLAY, thegame);
	return;
    }

    while (1)
    {
	Fl::check ();

	if (thegame->player[0].fulltime != -1)
	{
	    if (thegame->player[0].timer <= 0.0)
	    {
		winner = 'x';
		break;
	    }
	    if (thegame->player[1].timer <= 0.0)
	    {
		winner = 'o';
		break;
	    }
	}

	if (interrupt_computer)
	{
	    stoptimer (thegame);
	    interrupt_computer = 0;
	    thegame->state = GAME_STOP;
	    break;
	}
	
	changeinterface (INTERFACE_PLAY, thegame);

	if (b_status (thegame->boards[0]) == S_NORMAL)
	{
	    nextpiece = b_next_piece (thegame->boards[0]);
	    /* check if gipf-pieces left */
	    if (thegame->game_type != T_BASIC)
	    {
		if (((b_move_counter (thegame->boards[0]) > 1) || 
		     (thegame->game_type == T_OTHER) || (nextpiece == 'x')) && 
		    (b_white_gipf (thegame->boards[0]) == 0))
		{
		    winner = 'x';
		    break;
		}
		else if ((b_move_counter (thegame->boards[0]) > 1) && 
			 (b_black_gipf (thegame->boards[0]) == 0))
		{
		    winner = 'o';
		    break;
		}
	    }
	    if (b_colour (thegame->boards[0], nextpiece) == 0)
	    {   /* game finished */
		winner = b_opponent (nextpiece);
		break;
	    }

	    if (thegame->player[pnr(nextpiece)].type == 0)
	    {   /* human player */
		gameboard->setto (NULL);
		gameboard->setfrom (NULL);
		if (b_colour_type (thegame->boards[0], nextpiece) == 'g')
		    gameboard->setgipfpossible (1);
		else
		    gameboard->setgipfpossible (0);

		starttimer (thegame, nextpiece);
		break;
	    }
	    else
	    {   /* computer player */
		fl_cursor (FL_CURSOR_WAIT);
		Fl::check ();
		
		computermove (thegame);

		fl_cursor (FL_CURSOR_DEFAULT);
	    }
	}
	else if (b_status (thegame->boards[0]) == S_REMOVEGIPF)
	{
	    gipf_questions (thegame);
	}
	else if (b_status (thegame->boards[0]) == S_REMOVEROW)
	{
	    row_questions (thegame);
	}
    }

    if (winner != ' ')
    {
	sprintf (tempstr, "Player %s, you have won after %d moves !", 
		 thegame->player[pnr(winner)].name, 
		 b_move_counter (thegame->boards[0]));
	gf1_alert (tempstr);
	thegame->state = GAME_STOP;
    }

    changeinterface (INTERFACE_PLAY, thegame);
    Fl::check ();
    return;
}


void computermove (gamestruct * thegame)
{
    char nextpiece,
	piecetype,
	from[3] = "  ",
	to[3] ="  ",
	piece;
    int playertype;
    board * temp_board,
	* new_board = NULL;
    Fl_Window * thinkwindow;
    
    temp_board = b_copy (thegame->boards[0]);
    nextpiece = b_next_piece (thegame->boards[0]);
    piecetype = b_colour_type (thegame->boards[0], nextpiece);
    playertype = thegame->player[pnr(nextpiece)].type;

    starttimer (thegame, nextpiece);

    thinkwindow = create_thinkwindow ();

    (* players[playertype].movefunc)
	(temp_board, thegame->player[pnr(nextpiece)].self, 
	 thegame->player[pnr(nextpiece)].timer, 
	 &piecetype, from, to);

    Fl::check ();
    delete thinkwindow;

    stoptimer (thegame);
    if (interrupt_computer)
	return;

    if ((b_colour_type (thegame->boards[0], nextpiece) != 'g') &&
	(piecetype == 'g'))
    {
	piecetype = 'n';
    }

    piece = piecetype == 'g' ? b_otherpiece (nextpiece) : nextpiece;

    b_setlog (thegame->boards[0], thegame->movelog);
    new_board = b_move (thegame->boards[0], from, to, piece);
    b_nolog (thegame->boards[0]);
    b_nolog (new_board);

    b_del (temp_board);
    if (new_board == NULL)
    {
	gf1_alert ("the computer-player executed an invalid move !!");

//	b_del (thegame->boards[0]);
//	(* players[thegame->player[0].type].endfunc)(thegame->player[0].self);
//	(* players[thegame->player[1].type].endfunc)(thegame->player[1].self);
//	thegame->boards[0] = NULL;
    }
    else
    {
	b_del (thegame->boards[2]);
	thegame->boards[2] = thegame->boards[1];
	thegame->boards[1] = thegame->boards[0];
	thegame->boards[0] = new_board;

	analysemove (thegame, playertype);

	gameboard->setboard (thegame->boards[0]);
    }

    return;
}


int humanmove (gamestruct * thegame)
{
    char nextpiece,
	piece;
    int playertype;
    board * new_board = NULL;
    char * from,
	* to,
	piecetype;

    if (thegame->state == GAME_STOP)
	return (0);

    from = postostr (gameboard->getfrom ());
    to = postostr (gameboard->getto ());
    if (gameboard->getptype ())
	piecetype = 'g';
    else
	piecetype = 'n';

    nextpiece = b_next_piece (thegame->boards[0]);
    playertype = thegame->player[pnr(nextpiece)].type;

    if ((b_colour_type (thegame->boards[0], nextpiece) != 'g') &&
	(piecetype == 'g'))
    {
	piecetype = 'n';
    }

    piece = piecetype == 'g' ? b_otherpiece (nextpiece) : nextpiece;

    b_setlog (thegame->boards[0], thegame->movelog);
    new_board = b_move (thegame->boards[0], from, to, piece);
    b_nolog (thegame->boards[0]);
    if (new_board != NULL)
	b_nolog (new_board);

    free (from);
    free (to);

    if (new_board == NULL)
    {
	return (-1);
    }

    stoptimer (thegame);

    b_del (thegame->boards[2]);
    thegame->boards[2] = thegame->boards[1];
    thegame->boards[1] = thegame->boards[0];
    thegame->boards[0] = new_board;

    analysemove (thegame, 0);

    gameboard->setto (NULL);
    gameboard->setfrom (NULL);
    gameboard->setboard (thegame->boards[0]);

    return (0);
}


void row_questions (gamestruct * thegame)
{
    board * temp_board,
	* new_board;
    int counter;
    rem_row * row;
    listheader * rowlist;
    char owner,
	response,
	* start,
	* end,
	tempstr1[100],
	tempstr2[100];
    int answer;

    temp_board = b_copy (thegame->boards[0]);
    counter = 1;
    rowlist = b_row_extra (thegame->boards[0]);
    while ((row = (rem_row *) llitembynr (rowlist, counter)) != NULL)
    {
	counter++;
	start = postostr (row->startpos);
	end = postostr (row->endpos);
	owner = row_owner (row);
		
	starttimer (thegame, owner);
	if (thegame->player[pnr(owner)].type == 0)
	{   /* human */
	    gameboard->setrow (row->piecelist);
	    gameboard->setboard (thegame->boards[0]);

	    sprintf (tempstr1, "Player %s, do you want to remove",
		     thegame->player[pnr(owner)].name);
	    sprintf (tempstr2, "the row from %s to %s", start, end);

	    answer = 2;
	    while (answer == 2)
	    {
		answer = gf1_questionsave (tempstr1, tempstr2);

		if (answer == 2)
		    savegame (thegame);
		else if (answer == 1)
		    response = 'y';
		else
		    response = 'n';
	    }

	    gameboard->setrow (NULL);
	}
	else
	{   /* computer */
	    Fl_Window * thinkwindow;
    
	    thinkwindow = create_thinkwindow ();

	    response = 
		(* players[thegame->player[pnr(owner)].type].rowfunc)
		(temp_board, thegame->player[pnr(owner)].self, 
		 thegame->player[pnr(owner)].timer, start, end);

	    delete thinkwindow;
	}
	stoptimer (thegame);
	if (interrupt_computer)
	    return;
		
	free (start);
	free (end);

	if (response == 'y')
	{
	    b_setlog (thegame->boards[0], thegame->movelog);
	    new_board = b_remove_row (thegame->boards[0], counter-1);
	    b_nolog (new_board);
	    b_del (thegame->boards[0]);
	    thegame->boards[0] = new_board;

	    analysemove (thegame, thegame->player[pnr(owner)].type);

	    gameboard->setboard (thegame->boards[0]);

	    break;
	}
    }
    b_del (temp_board);

    return;
}


void gipf_questions (gamestruct * thegame)
{
    int counter;
    rem_gipf * gipf;
    board * nboard,
	* new_board,
	* temp_board;
    listheader * gipflist;
    char owner,
	* strpos,
	response;
    char tempstr1[100],
	tempstr2[100];
    int answer;

    counter = 1;
    gipflist = b_gipf_extra (thegame->boards[0]);
    new_board = thegame->boards[0];

    while ((gipf = (rem_gipf *) llitembynr (gipflist, counter)) != NULL)
    {
	counter++;
	strpos = b_gipf_position (gipf);
	owner = b_gipf_owner (gipf);

	starttimer (thegame, owner);
	if (thegame->player[pnr(owner)].type == 0)
	{   /* human */
	    gameboard->setto (gipf->pos);
	    gameboard->setboard (new_board);

	    sprintf (tempstr1, "Player %s, do you want to remove",
		     thegame->player[pnr(owner)].name);
	    sprintf (tempstr2, "the GIPF at %s", strpos);

	    answer = 2;
	    while (answer == 2)
	    {
		/*
		** only allow saving of the game at the first question
		** for removing a gipf.
		** things get fishy if you would save from here after a gipf
		** has been removed already.
		** (the problem doesn't occur immediatly, but when you load
		**  the game again)
		*/
		if (counter == 2)
		    answer = gf1_questionsave (tempstr1, tempstr2);
		else
		    answer = gf1_question (tempstr1, tempstr2);
		    

		if (answer == 2)
		    savegame (thegame);
		else if (answer == 1)
		    response = 'y';
		else
		    response = 'n';
	    }

	    gameboard->setto (NULL);
	}
	else
	{   /* computer */
	    Fl_Window * thinkwindow;
    
	    thinkwindow = create_thinkwindow ();

	    temp_board = b_copy (new_board);
	    response = (* players[thegame->player[pnr(owner)].type].gipffunc)
		(temp_board, thegame->player[pnr(owner)].self, 
		 thegame->player[pnr(owner)].timer, strpos);
	    b_del (temp_board);

	    delete thinkwindow;
	}
	stoptimer (thegame);
	if (interrupt_computer)
	    return;

	if ((response == 'y') || (response == 'Y'))
	{
	    b_setlog (new_board, thegame->movelog);
	    nboard = b_remove_gipf (new_board, gipf);
	    b_nolog (new_board);
	    b_nolog (nboard);

	    if (new_board != thegame->boards[0])
		b_del (new_board);

	    new_board = nboard;

	    analysemove (thegame, thegame->player[pnr(owner)].type);

	    gameboard->setboard (new_board);
	}
	free (strpos);
    }

    b_setlog (new_board, thegame->movelog);
    nboard = b_checkfour (new_board);
    b_nolog (new_board);
    b_nolog (nboard);
    if (new_board != thegame->boards[0])
	b_del (new_board);
   
    b_del (thegame->boards[0]);
    thegame->boards[0] = nboard;
    
    analysemove (thegame, 1);

    gameboard->setboard (thegame->boards[0]);

    return;
}


//time_t basetime = 0;
struct timeval basetime;
char timercolor;

void starttimer (gamestruct * thegame, char color)
{
    struct timezone tz;

    if (thegame->player[0].fulltime == -1)
    {
	basetime.tv_sec = 0;
	return;
    }

//    basetime = time (NULL);
    gettimeofday (&basetime, &tz);
    timercolor = color;

    Fl::add_timeout (1.0, updatetimer, (void *) thegame);

    return;
}


void stoptimer (gamestruct * thegame)
{
//    time_t newtime;
    struct timezone tz;
    struct timeval tv;
    float timedif;
    char tempstr[20];

    if ((thegame == NULL) || (basetime.tv_sec == 0))
	return;

    Fl::remove_timeout (updatetimer, (void *) thegame);

//    newtime = time (NULL);
    gettimeofday (&tv, &tz);
    timedif = (tv.tv_sec - basetime.tv_sec) +
	(float) (tv.tv_usec - basetime.tv_usec)/1000000;

    if (timercolor == 'o')
    {
	if (interrupt_computer == 0)
	    thegame->player[0].timer -= timedif;
	timertostr (thegame->player[0].timer, tempstr);
	whitetimer->value (tempstr);
    }
    else
    {
	if (interrupt_computer == 0)
	    thegame->player[1].timer -= timedif;
	timertostr (thegame->player[1].timer, tempstr);
	blacktimer->value (tempstr);
    }

    basetime.tv_sec = 0;
    return;
}


void updatetimer (void * data)
{
    gamestruct * thegame = (gamestruct *) data;
//    time_t newtime;
    struct timezone tz;
    struct timeval tv;
    float timedif;
    float newtimer;
    char tempstr[20];

//    newtime = time (NULL);
    gettimeofday (&tv, &tz);
    timedif = (tv.tv_sec - basetime.tv_sec) +
	(float) (tv.tv_usec - basetime.tv_usec)/1000000;

    if (timercolor == 'o')
    {
	newtimer = thegame->player[0].timer - timedif;
	timertostr (newtimer, tempstr);
	whitetimer->value (tempstr);
    }
    else
    {
	newtimer = thegame->player[1].timer - timedif;
	timertostr (newtimer, tempstr);
	blacktimer->value (tempstr);
    }

    if (newtimer > 0.0)
	Fl::add_timeout (1.0, updatetimer, data);
    else
    {   /* timer ran out, show if this is a human move */
	if (timercolor == 'o')
	{
	    if (thegame->player[0].type == 0)
	    {
		thegame->player[0].timer = newtimer;
		
		setupmove (thegame);
	    }
	}
	else if (thegame->player[1].type == 0)
	{
	    thegame->player[1].timer = newtimer;

	    setupmove (thegame);
	}
    }

    return;
}


/*
** analyse the entries added to the gamelog
** since the last time we ran this function
** show what needs to be shown to the user
*/
void analysemove (gamestruct * thegame, int playertype)
{
    int counter = thegame->movecounter + 1;
    logitem * item;

    while ((item = logitemnr (thegame->movelog, counter)) != NULL)
    {
	switch (logitem_type (item))
	{
	case LOGMOVE:
	    showmove (thegame, playertype, item);
	    break;
	case LOGREMGIPF:
	    showremgipf (thegame, playertype, item);
	    break;
	case LOGREMROW:
	    showremrow (thegame, playertype, item);
	    break;
	}

	counter++;
	playertype = 1; /* necessary in case a row is removed automatically */
    }
    thegame->movecounter = counter - 1;

    /* show the correct board */
    gameboard->setboard (thegame->boards[0]);

    return;
}


void showmove (gamestruct * thegame, int playertype, logitem * item)
{
    char start[3] = "  ",
	end[3] = "  ";
    position * startpos,
	* endpos,
	* topos;
    int dir,
	counter;
    listheader * plist;
    struct movepiece {
	char piece;
	position * from;
	position * to;
    } * mpiece;
    board * oldboard,
	* newboard,
	* nboard;

    strncpy (start, logitem_start (item), 2);
    strncpy (end, logitem_end (item), 2);
    startpos = strtopos (start);
    endpos = strtopos (end);
    topos = new_position ();

    /*
    **from the start and the end of the move we can find the to-position 
    ** and the direction of the move
    */
    if (posp_col (startpos) == posp_col (endpos))
    {
	posp_col (topos) = posp_col (startpos);
	if (posp_row (startpos) > posp_row (endpos))
	{
	    posp_row (topos) = posp_row (startpos) - 1;
	    dir = 2;
	}
	else
	{
	    posp_row (topos) = posp_row (startpos) + 1;
	    dir = 3;
	}
    }
    else if (posp_col (startpos) < posp_col (endpos))
    {
	posp_col (topos) = posp_col (startpos) + 1;
	if (posp_row (startpos) >= posp_row (endpos))
	{
	    posp_row (topos) = posp_row (startpos);
	    dir = 4;
	}
	else
	{
	    posp_row (topos) = posp_row (startpos) + 1;
	    dir = 5;
	}
    }
    else
    {
	posp_col (topos) = posp_col (startpos) - 1;
	if (posp_row (startpos) >= posp_row (endpos))
	{
	    posp_row (topos) = posp_row (startpos);
	    dir = 0;
	}
	else
	{
	    posp_row (topos) = posp_row (startpos) + 1;
	    dir = 1;
	}
    }

    /*
    ** reasons to wait before showing the move
    **    - waitcomputer > 0
    **    - move by the computer
    */
    if ((playertype != 0) &&
	(thegame->config->waitcomputer > 0))
    {   /* computerplayer */
	if ((logitem_player (item) == 'O') ||
	    (logitem_player (item) == 'X'))
	{
	    gameboard->setgipfpossible (1);
	}
	else
	{
	    gameboard->setgipfpossible (0);
	}
	gameboard->setfrom (startpos);
	gameboard->setto (topos);

 	/* the first Fl::wait is necessary to reset the start of the timer */
	Fl::wait (0);
	for (float time = thegame->config->waitcomputer * 1.0; time > 0; ) 
	    time = Fl::wait(time);
#if 0
	Fl::check ();
#ifdef MSWIN
	sleep (thegame->config->waitcomputer * 1000);
#else
	sleep (thegame->config->waitcomputer);
#endif
#endif
    }
    gameboard->setto (NULL);
    gameboard->setfrom (NULL);


    /*
    ** make a list of all the pieces that move 
    ** + from and to position
    */
    plist = (listheader *) malloc (sizeof (listheader));
    newlist (plist);
    mpiece = (struct movepiece *) malloc (sizeof (struct movepiece));
    mpiece->piece = logitem_player (item);
    mpiece->from = (position *) copy_position ((void *) startpos);
    mpiece->to = (position *) copy_position ((void *) topos);
    pushll (plist, mpiece);
    while ((posp_col (topos) != posp_col (endpos)) ||
	   (posp_row (topos) != posp_row (endpos)))	
    {
	posp_col (startpos) = posp_col (topos);
	posp_row (startpos) = posp_row (topos);
	posp_col (topos) = 
	    b_buren[posp_col (startpos)][posp_row (startpos)][dir][0];
	posp_row (topos) = 
	    b_buren[posp_col (startpos)][posp_row (startpos)][dir][1];

	mpiece = (struct movepiece *) malloc (sizeof (struct movepiece));
	mpiece->piece = b_ppiece (gameboard->getboard (), startpos);
	mpiece->from = (position *) copy_position ((void *) startpos);
	mpiece->to = (position *) copy_position ((void *) topos);
	pushll (plist, mpiece);
    }

    /*
    ** reason to animate the move
    **    - animate > 0
    */
    if (thegame->config->animate > 0)
    {   /* animate */
	int steps = 10;
	switch (thegame->config->animate)
	{
	case 1: /* slow */
	    steps = 20;
	    break;
	case 2: /* medium */
	    steps = 13;
	    break;
	case 3: /* fast */
	    steps = 8;
	    break;
	}
	gameboard->initanim (steps, plist);

//	Fl::wait (0);
	for (int i = 0; i <= steps; i++)
	{
	    gameboard->animstep (i);
#ifdef MSWIN
	    /* this timing looks a little better on ms windows */
	    for (float time = 0.02; time > 0; ) 
		time = Fl::wait(time);
#else
	    for (float time = 0.03; time > 0; ) 
		time = Fl::wait(time);
#endif
	}
    }

    /* update board */
    nboard = oldboard = gameboard->getboard ();
    counter = 1;
    while ((mpiece = (struct movepiece *) llitembynr (plist, counter)) 
	   != NULL)
    {
	counter++;
	newboard = b_edit_piece (nboard, mpiece->to, mpiece->piece);
	if (nboard != oldboard)
	    b_del (nboard);
	nboard = newboard;
    }
    gameboard->setboard (nboard);
    if (nboard != oldboard)
	b_del (nboard);

    /* cleanup */
    while ((mpiece = (struct movepiece *) llrembynr (plist, 1)) != NULL)
    {
	free (mpiece->from);
	free (mpiece->to);
	free (mpiece);
    }
    free (plist);
    del_position (startpos);
    del_position (endpos);
    del_position (topos);

    return;
}


void showremgipf (gamestruct * thegame, int playertype, logitem * item)
{
    listheader * piecelist;
    char * piece,
	posstr[3] =  "  ";
    position * ppos;
    board * oldboard,
	* newboard;

    piecelist = logitem_plist (item);
    piece = (char *) llitembynr (piecelist, 1);
    strncpy (posstr, piece, 2);
    ppos = strtopos (posstr);

    /* 
    ** reasons for showing the removal of a gipf
    **    - waitremove > 0
    **    - gipf removed by a computer-player
    */
    if ((playertype != 0) &&
	(thegame->config->waitremove > 0))
    {   /* computerplayer */
	gameboard->setfrom (NULL);
	gameboard->setto (ppos);

 	/* the first Fl::wait is necessary to reset the start of the timer */
	Fl::wait (0);
	for (float time = thegame->config->waitremove * 1.0; time > 0; ) 
	    time = Fl::wait(time);
#if 0
	Fl::check ();
#ifdef MSWIN
	sleep (thegame->config->waitremove * 1000);
#else
	sleep (thegame->config->waitremove);
#endif
#endif
    }
    gameboard->setto (NULL);

    /* now we update the gameboard */
    oldboard = gameboard->getboard ();
    newboard = b_edit_piece (oldboard, ppos, '.');
    gameboard->setboard (newboard);
    b_del (newboard);

    del_position (ppos);

    return;
}


void showremrow (gamestruct * thegame, int playertype, logitem * item)
{
    listheader * poslist,
	* piecelist;
    char start[3] =  "  ",
	end[3] = "  ",
	posstr[3] = "  ",
	* ptr;
    int dir,
	counter;
    position * ppos,
	* prevpos,
	* startpos,
	* endpos;
    board * oldboard,
	* newboard,
	* nboard;

    strncpy (start, logitem_start (item), 2);
    strncpy (end, logitem_end (item), 2);
    startpos = strtopos (start);
    endpos = strtopos (end);

    /* find the direction between start and end */
    if (posp_col (startpos) == posp_col (endpos))
    {
	if (posp_row (startpos) > posp_row (endpos))
	    dir = 2;
	else
	    dir = 3;
    }
    else if (posp_col (startpos) < posp_col (endpos))
    {
	if (posp_row (startpos) > posp_row (endpos))
	    dir = 4;
	else if (posp_row (startpos) < posp_row (endpos))
	    dir = 5;
	else
	{
	    if (posp_col (startpos) < 4)
		dir = 4;
	    else
		dir = 5;
	}
    }
    else
    {
	if (posp_row (startpos) > posp_row (endpos))
	    dir = 0;
	else if (posp_row (startpos) < posp_row (endpos))
	    dir = 1;
	else
	{
	    if (posp_col (startpos) > 4)
		dir = 0;
	    else
		dir = 1;
	}
    }


    /* make a list with all positions between start and end */
    piecelist = logitem_plist (item);
    poslist = (listheader *) malloc (sizeof (listheader));
    newlist (poslist);

    pushll (poslist, startpos);

    prevpos = startpos;
    while ((b_buren[posp_col(prevpos)][posp_row(prevpos)][dir][0] 
	    != posp_col(endpos)) || 
	   (b_buren[posp_col(prevpos)][posp_row(prevpos)][dir][1] 
	    != posp_row(endpos)))
    {
	ppos = new_position ();
	posp_col(ppos) = b_buren[posp_col(prevpos)][posp_row(prevpos)][dir][0];
	posp_row(ppos) = b_buren[posp_col(prevpos)][posp_row(prevpos)][dir][1];

	pushll (poslist, ppos);
	prevpos = ppos;
    }
    pushll (poslist, endpos);

    /* 
    ** reasons for showing the removal of a row
    **    - waitremove > 0
    **    - row automatically removed 
    **      or row removed by a computer-player
    */
    if ((playertype != 0) &&
	(thegame->config->waitremove > 0))
    {   /* computerplayer */
	gameboard->setrow (poslist);

 	/* the first Fl::wait is necessary to reset the start of the timer */
	Fl::wait (0);
	for (float time = thegame->config->waitremove * 1.0; time > 0; ) 
	    time = Fl::wait(time);
#if 0
	Fl::check ();
#ifdef MSWIN
	sleep (thegame->config->waitremove * 1000);
#else
	sleep (thegame->config->waitremove);
#endif
#endif
    }
    gameboard->setrow (NULL);

    /* cleanup */
    while ((ppos = (position *) llrembynr (poslist, 1)) != NULL)
    {
	free (ppos);
    }
    free (poslist);

    /* now we update the gameboard */
    poslist = logitem_plist (item);
    oldboard = gameboard->getboard ();
    nboard = oldboard;
    counter = 1;
    while ((ptr = (char *) llitembynr (poslist, counter)) != 0)
    {
	counter++;
	strncpy (posstr, ptr, 2);
	ppos = strtopos (posstr);
	newboard = b_edit_piece (nboard, ppos, '.');
	if (nboard != oldboard)
	    b_del (nboard);
	nboard = newboard;
	free (ppos);
    }
    gameboard->setboard (nboard);
    
    if (nboard != oldboard)
	b_del (nboard);

    return;
}


/*
** this doesn't make gif-files anymore, but png-files
*/
void show_makegif (board * game)
{
#ifdef HAVEGD
    Fl_Window * gifw;
    drawgif drawing;
    char * str;
    int i;
    static int def_size = 300,
	def_colour = 1;

    gifw = make_gifwindow ();

    // set default values
    gif_filename->value ("./game.png");
    gif_size->value (def_size);
    if (def_colour)
	gif_colour->setonly ();
    else
	gif_bw->setonly ();
    gif_extratext->value (NULL);

    gifw->show ();

    while (1)
    {
	Fl::wait();    

	Fl_Widget *x;
	while ((x = Fl::readqueue())) 
	{
	    if (x == gif_choose)
	    {
		if ((str = file_chooser ("Filename", "*.gif", 
					 gif_filename->value ())) != NULL)
		{
		    gif_filename->value (str);
		}
	    }
	    else if (x == gif_ok)
	    {
		drawing.filename (gif_filename->value ());
		def_size = (int) gif_size->value ();
		drawing.gifsize (def_size);
		drawing.gifboard (game);
		if (gif_colour->value ())
		    def_colour = 1;
		else
		    def_colour = 0;
		drawing.gifcolour (def_colour);

		str = gif_extratext->value ();
		// check if the string contains something
		for (i = 0; i < strlen (str); i++)
		{
		    if (! isspace ((int) str[i]))
		    {
			drawing.addtext (str);
			break;
		    }
		}
		drawing.draw ();

		delete gifw;
		return;
	    }
	    else if (x == gif_cancel)
	    {
		delete gifw;
		return;
	    }
	}
    }
#endif

    return;
}
@


1.34
log
@new loading and saving code
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.33 1999/06/01 16:47:54 kurt Exp kurt $
a28 1
#include <FL/fl_file_chooser.H>
d208 3
d323 3
d442 2
d759 1
a759 1
    if ((filename = fl_file_chooser ("load game", "*.gf1", NULL)) == NULL)
d847 2
d860 2
a861 1
    char tempstr[100];
d870 6
a875 1
    if ((filename = fl_file_chooser ("save game", "*.gf1", "savegame.gf1")) 
d917 2
d1944 1
a1944 1
    gif_filename->value ("game.png");
d1963 2
a1964 2
		if ((str = fl_file_chooser ("Filename", "*.gif", 
					    gif_filename->value ())) != NULL)
@


1.33
log
@updates for correct handling of timed games by the computerplayer
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.32 1999/01/07 13:56:43 kurt Exp kurt $
d43 1
d46 1
d621 2
d627 1
a627 1
gamestruct * loadgame (void)
d629 1
a629 2
    char * filename,
	buffer[100],
a635 6
    // ask for filename
    if ((filename = fl_file_chooser ("load game", "*.gf1", NULL)) == NULL)
    {
	return (NULL);
    }

d736 109
d850 2
a851 2
    FILE * fp;
    int i;
d866 32
a897 5
    if ((fp = fopen (filename, "w")) == NULL)
    {
	gf1_alert (" ERROR: Can't create the file");
	return;
    }
d899 2
a900 28
    fprintf (fp, "# saved game for gf1\n");
    // gametype
    fprintf (fp, "# gametype: %d\n", gameptr->game_type);

    // players
    for (i = 0; i < 2; i++)
    {
	fprintf (fp, "# player%d type: %d\n", i, gameptr->player[i].type);
	fprintf (fp, "# player%d name: %s\n", i, gameptr->player[i].name);
	fprintf (fp, "# player%d fulltime: %d\n", i, 
		 gameptr->player[i].fulltime);
	fprintf (fp, "# player%d timer: %f\n", i, gameptr->player[i].timer);

	/*
	** remark: I can't save 'self' here
	**         this has to be added to the documentation
	*/
    }

    // save last gameboard
    fprintf (fp, "# gameboard\n");
    b_to_file (gameptr->boards[0], fp);

    // save gamelog
    fprintf (fp, "# gamelog\n");
    logtofile (gameptr->movelog, fp);

    fclose (fp);
d1187 13
a1199 6
	    answer = gf1_question (tempstr1, tempstr2);
	    
	    if (answer == 1)
		response = 'y';
	    else
		response = 'n';
a1277 1
	    answer = gf1_question (tempstr1, tempstr2);
d1279 24
a1302 4
	    if (answer == 1)
		response = 'y';
	    else
		response = 'n';
d1911 3
d1927 1
a1927 1
    gif_filename->value ("game.gif");
@


1.32
log
@changes on MSWIN because I don't have a gettimeofday there.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.31 1999/01/06 20:28:51 kurt Exp kurt $
d178 1
a178 1
		    newgame->player[0].timer = -1;
d180 1
a180 1
		    newgame->player[1].timer = -1;
d284 1
a284 1
		newgame->player[0].timer = -1;
d286 1
a286 1
		newgame->player[1].timer = -1;
d393 1
a393 1
		newgame->player[0].timer = -1;
d395 1
a395 1
		newgame->player[1].timer = -1;
d934 3
a936 2
	(temp_board, thegame->player[pnr(nextpiece)].self, &piecetype,
	 from, to);
d1097 2
a1098 1
		(temp_board, thegame->player[pnr(owner)].self, start, end);
d1181 2
a1182 1
		(temp_board, thegame->player[pnr(owner)].self, strpos);
@


1.31
log
@changed timekeeping.
to improve the resolution of the clock, internally time is now kept as
a float.
time-measurements are done with gettimeofday() instead of time(), this
allows (in principle) an accuracy of 1 usecond.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.30 1998/12/13 15:46:56 kurt Exp kurt $
d32 4
@


1.30
log
@added show_makegif for saving the board-position as a gif-file
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.29 1998/11/27 13:37:59 kurt Exp kurt $
d27 1
d164 6
a169 4
		    newgame->player[0].fulltime = 
			newgame->player[0].timer = 60* (int)whitetime->value();
		    newgame->player[1].fulltime = 
			newgame->player[1].timer = 60* (int)blacktime->value();
d173 4
a176 4
		    newgame->player[0].fulltime = 
			newgame->player[0].timer = -1;
		    newgame->player[0].fulltime = 
			newgame->player[1].timer = -1;
d279 4
a282 2
		newgame->player[0].fulltime = newgame->player[0].timer = -1;
		newgame->player[0].fulltime = newgame->player[1].timer = -1;
d388 4
a391 2
		newgame->player[0].fulltime = newgame->player[0].timer = -1;
		newgame->player[0].fulltime = newgame->player[1].timer = -1;
d692 1
a692 1
	if (sscanf (buffer, "# player%d timer: %d", 
d773 1
a773 1
	fprintf (fp, "# player%d timer: %d\n", i, gameptr->player[i].timer);
d813 1
a813 1
	    if (thegame->player[0].timer <= 0)
d818 1
a818 1
	    if (thegame->player[1].timer <= 0)
d1221 2
a1222 1
time_t basetime = 0;
d1227 2
d1231 1
a1231 1
	basetime = 0;
d1235 2
a1236 1
    basetime = time (NULL);
d1247 4
a1250 1
    time_t newtime;
d1253 1
a1253 1
    if ((thegame == NULL) || (basetime == 0))
d1258 4
a1261 1
    newtime = time (NULL);
d1266 1
a1266 1
	    thegame->player[0].timer -= (newtime - basetime);
d1273 1
a1273 1
	    thegame->player[1].timer -= (newtime - basetime);
d1278 1
a1278 1
    basetime = 0;
d1286 5
a1290 2
    time_t newtime;
    int newtimer;
d1293 4
a1296 1
    newtime = time (NULL);
d1300 1
a1300 1
	newtimer = thegame->player[0].timer - (newtime - basetime);
d1306 1
a1306 1
	newtimer = thegame->player[1].timer - (newtime - basetime);
d1311 1
a1311 1
    if (newtimer > 0)
d1812 1
a1812 1
		def_size = gif_size->value ();
@


1.29
log
@bug with T_OTHER game when somebody ran out of gipf-pieces at the start
of the game.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.28 1998/11/26 17:57:11 kurt Exp kurt $
d26 1
d37 1
d1743 78
@


1.28
log
@implemented show_onemove and show_start
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.27 1998/11/15 11:59:32 kurt Exp kurt $
d833 1
a833 1
		     (nextpiece == 'x')) && 
@


1.27
log
@started implementing show_start and show_onemove. NOT finished yet.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.26 1998/11/09 20:32:12 kurt Exp kurt $
d37 1
a37 1
char gametype[3][15] = {"basic", "standard", "tournament"};
d147 8
a154 6
		if (radio_whuman->value()) { newgame->player[0].type = 0; }
		else if (radio_wcompu->value()) { newgame->player[0].type = 1;}
		else { return (NULL); }
		if (radio_bhuman->value()) { newgame->player[1].type = 0; }
		else if (radio_bcompu->value()) { newgame->player[1].type = 1;}
		else { return (NULL); }
d224 6
d232 14
d257 50
a306 1
		gf1_alert ("Start game from gameboard not implemented yet!");
d308 1
a308 1
		return (NULL);
d312 1
d331 1
a331 1
gamestruct * show_onemove (board * startboard)
d335 8
d360 60
a419 1
		gf1_alert ("One computermove not implemented yet!");
d421 16
a436 1
		return (NULL);
d440 1
d448 127
@


1.26
log
@stop game if human player runs out of time.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.25 1998/11/04 19:19:27 kurt Exp kurt $
d201 86
@


1.25
log
@changed the time to wait when animating a move on ms windows
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.24 1998/11/01 16:27:39 kurt Exp kurt $
d920 18
@


1.24
log
@added copyright
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.23 1998/11/01 14:08:38 kurt Exp kurt $
d1124 5
d1131 1
@


1.23
log
@made the move-animation better
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.22 1998/11/01 11:27:39 kurt Exp kurt $
d5 17
@


1.22
log
@implemented move-animation
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.21 1998/11/01 08:58:11 kurt Exp kurt $
d809 1
d811 2
d818 2
d1086 1
a1086 18
    if (thegame->config->animate == 0)
    {   /* no animation, just show the new position */
	nboard = oldboard = gameboard->getboard ();
	counter = 1;
	while ((mpiece = (struct movepiece *) llitembynr (plist, counter)) 
	       != NULL)
	{
	    counter++;
	    newboard = b_edit_piece (nboard, mpiece->to, mpiece->piece);
	    if (nboard != oldboard)
		b_del (nboard);
	    nboard = newboard;
	}
	gameboard->setboard (nboard);
	if (nboard != oldboard)
	    b_del (nboard);
    }
    else
d1111 16
@


1.21
log
@replaced sleep () by Fl::wait (time) in a loop, now events are still handled
when a move is shown.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.20 1998/10/28 18:29:37 kurt Exp kurt $
d1081 14
a1094 8

/* no animation yet, just show the new position */
    nboard = oldboard = gameboard->getboard ();
    counter = 1;
    while ((mpiece = (struct movepiece *) llitembynr (plist, counter)) != NULL)
    {
	counter++;
	newboard = b_edit_piece (nboard, mpiece->to, mpiece->piece);
a1096 1
	nboard = newboard;
d1098 25
a1122 3
    gameboard->setboard (nboard);
    if (nboard != oldboard)
	b_del (nboard);
@


1.20
log
@showing the results of a move should work OK now, only move
animation isn't implemented yet.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.19 1998/10/27 20:37:27 kurt Exp kurt $
d1020 9
d1032 5
a1036 1
/* maybe I should do this with a timeout */
d1043 1
d1138 5
a1142 1
/* maybe I should do this with a timeout */
d1149 1
d1259 5
a1263 1
/* maybe I should do this with a timeout */
d1269 1
@


1.19
log
@lots of changes for making it possible to show what happened since the
last move to the user.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.18 1998/10/25 20:12:13 kurt Exp kurt $
d9 1
a523 1
    position * temppos;
d538 2
a539 1
    
a551 38
//    if (waitcomputer > 0)
    {
	/* wait and show move on screen */
	temppos = strtopos (from);
	gameboard->setfrom (temppos);
	free (temppos);
	temppos = strtopos (to);
	gameboard->setto (temppos);
	free (temppos);
	if (piecetype == 'g')
	    gameboard->setgipfpossible (1);
	else
	    gameboard->setgipfpossible (0);

// why should I want to do this    
//	gameboard->setboard (thegame->boards[0]);
	Fl::check ();

#ifdef MSWIN
//	sleep (waitcomputer * 1000);
#else
//	usleep (waitcomputer * 1000000L);
#endif

	gameboard->setfrom (NULL);
	gameboard->setto (NULL);

// I should do animation from the log-entry
// the same for human and computer (or is this not possible?)

//	// only do this if no animation
//	if (animate == 0)
//	{
//	    gameboard->setboard (thegame->boards[0]);
//	    theApp->CheckEvents ();
//	}
    }

a553 2
//    setremovewait (thegame->boards[0], 1);
//    setanimate (thegame->boards[0], 1);
a574 2
//	setremovewait (thegame->boards[0], 0);
//	setanimate (thegame->boards[0], 0);
a615 4
// animation should be done from the information added to the movelog
//
//    setremovewait (thegame->boards[0], 1);
//    setanimate (thegame->boards[0], 1);
a626 2
//	setremovewait (thegame->boards[0], 0);
//	setanimate (thegame->boards[0], 0);
a629 2
// be carefull when adding animation
// the timer must be stopped before the animation begins
a635 2
//    setremovewait (thegame->boards[0], 0);
//    setanimate (thegame->boards[0], 0);
a700 1
//	    setremovewait (thegame->boards[0], 1);
a720 1
//	    setremovewait (thegame->boards[0], 0);
a722 1
//	setremovewait (thegame->boards[0], 0);
a784 1
//	    setremovewait (new_board, 1);
a806 1
//	setremovewait (new_board, 0);
d947 2
a948 1
    int direction;
d955 3
d975 1
a975 1
	    direction = 2;
d980 1
a980 1
	    direction = 3;
d989 1
a989 1
	    direction = 4;
d994 1
a994 1
	    direction = 5;
d1003 1
a1003 1
	    direction = 0;
d1008 1
a1008 1
	    direction = 1;
a1012 5
    ** make a list of all the pieces that move 
    ** + from and to position
    */

    /*
d1017 2
a1018 1
    if (playertype != 0)
d1025 5
a1029 1
	sleep (1);
d1036 28
d1068 23
a1090 2
/* no animation yet */

d1118 2
a1119 1
    if (playertype != 0)
d1126 5
a1130 1
	sleep (1);
d1235 2
a1236 1
    if (playertype != 0)
d1242 5
a1246 1
	sleep (3);
d1250 1
a1254 1

@


1.18
log
@added analysemove ()
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.17 1998/10/22 16:59:57 kurt Exp kurt $
d726 1
a726 1
	    gameboard->setrow (row);
d974 1
a974 11
	    /*
	    ** reasons to wait before showing the move
	    **    - waitcomputer > 0
	    **    - move by the computer
	    */

	    /*
	    ** reason to animate the move
	    **    - animate > 0
	    */
//	    printf ("LOGMOVE\n");
d977 1
a977 6
	    /* 
	    ** reasons for showing the removal of a gipf
	    **    - waitremove > 0
	    **    - gipf removed by a computer-player
	    */
//	    printf ("LOGREMGIPF\n");
d980 1
a980 7
	    /* 
	    ** reasons for showing the removal of a row
	    **    - waitremove > 0
	    **    - row automatically removed 
	    **      or row removed by a computer-player
	    */
//	    printf ("LOGREMROW\n");
d985 1
d988 282
@


1.17
log
@stop displaying one of the players names with a red background when
the game has been stopped.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.16 1998/10/20 20:07:41 kurt Exp kurt $
d127 1
d325 1
d616 3
d688 2
d768 3
d856 3
d954 54
@


1.16
log
@changes for keeping a state for each game (GAME_GO, GAME_STOP)
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.15 1998/10/20 17:44:57 kurt Exp kurt $
d939 2
a940 1
    Fl::add_timeout (1.0, updatetimer, data);
@


1.15
log
@changes for getting the timers working correctly
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.14 1998/10/19 19:43:02 kurt Exp kurt $
d126 1
d246 1
d404 1
a404 1
    if (thegame == NULL)
d432 1
d502 1
d505 1
d630 3
@


1.14
log
@misc changes and updates
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.13 1998/10/18 18:02:35 kurt Exp kurt $
d402 6
a477 1
		starttimer (thegame, nextpiece);
a478 1
		stoptimer (thegame);
a518 2
    thinkwindow = create_thinkwindow ();

d524 4
d534 4
d740 2
d824 2
d893 1
a893 4
	sprintf (tempstr, "%d:%02d:%02d", 
		 thegame->player[0].timer / 3600,
		 (thegame->player[0].timer % 3600) / 60,
		 thegame->player[0].timer % 60);
d900 1
a900 4
	sprintf (tempstr, "%d:%02d:%02d", 
		 thegame->player[1].timer / 3600,
		 (thegame->player[1].timer % 3600) / 60,
		 thegame->player[1].timer % 60);
d921 1
a921 4
	sprintf (tempstr, "%d:%02d:%02d", 
		 newtimer / 3600,
		 (newtimer % 3600) / 60,
		 newtimer % 60);
d927 1
a927 4
	sprintf (tempstr, "%d:%02d:%02d", 
		 newtimer / 3600,
		 (newtimer % 3600) / 60,
		 newtimer % 60);
@


1.13
log
@added code for using the timers
+ misc. changes and bugfixes
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.12 1998/10/15 16:35:39 kurt Exp kurt $
a162 4
		newgame->pendingnew = 0;
		newgame->pendingexit = 0;
		newgame->computerthinking = 0;

a314 4
    newgame->pendingnew = 0;
    newgame->pendingexit = 0;
    newgame->computerthinking = 0;
	
a401 2
    thegame->computerthinking = 1;

d406 1
a406 9
//	if (game_type == -1)
//	{   /* no game in progress */
//	    SetString (lblplayer, "No game in progress.");
//	    SetValue (btnmove, 1, Hidden);
//
//	    break;
//	}

	if (thegame->pendingnew)
d408 11
a418 1
	    thegame->pendingnew = 0;
d420 1
a420 5
	    menubar->value (menu_new);
	    menubar->do_callback ();
	    break;
	}
	if (thegame->pendingexit)
d422 2
a423 4
	    thegame->pendingexit = 0;

	    menubar->value (menu_exit);
	    menubar->do_callback ();
a497 2

    thegame->computerthinking = 0;
d514 2
a515 8
    Fl_Widget * mainwin;

    thinkwindow = make_thinkwindow ();
    mainwin = logbrowser->parent ();
    thinkwindow->position (logbrowser->x() + mainwin->x() + 10,
			   logbrowser->y() + mainwin->y() + 10);
    thinkwindow->show ();
    Fl::wait();
d718 4
a721 1
//	    computerthinking = 1;
d725 2
a726 1
//	    computerthinking = 0;
d799 4
a803 1
//	    computerthinking = 1;
a805 1
//	    computerthinking = 0;
d807 2
d843 1
a843 1
time_t basetime;
d857 1
a857 1
    Fl::add_timeout (0.3, updatetimer, (void *) thegame);
d868 1
a868 1
    if (basetime == 0)
d877 2
a878 1
	thegame->player[0].timer -= (newtime - basetime);
d887 2
a888 1
	thegame->player[1].timer -= (newtime - basetime);
d895 3
d929 1
a929 1
    Fl::add_timeout (0.3, updatetimer, data);
@


1.12
log
@activate and deactivate the timercounters instead of hide and show.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.11 1998/10/15 16:31:46 kurt Exp kurt $
d11 1
d478 1
d486 1
d488 1
d529 9
d547 2
d676 4
d720 1
d730 1
a730 1

d747 1
d797 1
d825 1
d852 87
@


1.11
log
@you can play a real game now !!!
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.10 1998/10/14 19:27:23 kurt Exp kurt $
d91 2
a92 2
	whitetime->show();
	blacktime->show();
d96 2
a97 2
	whitetime->hide();
	blacktime->hide();
d113 2
a114 2
		    whitetime->show();
		    blacktime->show();
d118 2
a119 2
		    whitetime->hide();
		    blacktime->hide();
@


1.10
log
@loadgame() wasn't initialising some parameters
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.9 1998/10/14 19:12:37 kurt Exp kurt $
d440 2
a467 2
//changeinterface (INTERFACE_PLAY, thegame);

d470 2
a472 1
		{
a473 1
		}
a474 1
		{
d476 1
a476 1
		}
a483 1
//		computerthinking = 1;
a484 1
//		computerthinking = 0;
d554 3
a556 2
    
	gameboard->setboard (thegame->boards[0]);
d583 1
d585 2
d641 2
d645 1
d647 3
d733 1
d735 1
d806 1
d808 3
@


1.9
log
@first version that allows a minimal amount of playing
(with a lot of errors)
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.8 1998/10/12 19:14:11 kurt Exp kurt $
d317 4
@


1.8
log
@added functions for playing a game (copied from gipf_v)
!! this version is not stable !!
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.7 1998/10/11 08:57:07 kurt Exp kurt $
d10 1
a19 1

d161 4
d405 2
d440 1
a440 1
	    if (game_type != T_BASIC)
d462 3
a464 1
	    if (player[pnr(nextpiece)].playertype == 0)
a465 4
		sprintf (tempstr, "player %s, please enter your move. ",
			 player[pnr(nextpiece)].name);
		SetString (lblplayer, tempstr);
		SetValue (btnmove, 0, Hidden);
d468 1
a468 1
		    gipfCanvas->setgipfpossible (1);
d472 1
a472 1
		    gipfCanvas->setgipfpossible (0);
d478 2
a479 8
		sprintf (tempstr, "player %s is thinking...",
			 player[pnr(nextpiece)].name);
		SetString (lblplayer, tempstr);
		SetValue (btnmove, 1, Hidden);

		cursor = gipfCanvas->GetCursor ();
		gipfCanvas->SetCursor (VC_Wait);
		theApp->CheckEvents();
d481 3
a483 3
		computerthinking = 1;
		computermove ();
		computerthinking = 0;
d485 1
a485 1
		gipfCanvas->SetCursor (cursor);
d490 1
a490 1
	    gipf_questions ();
d494 1
a494 1
	    row_questions ();
d501 3
a503 14
		 player[pnr(winner)].name, b_move_counter (thegame->boards[0]));
	note.Notice(tempstr);
	fprintf (GIPFLOG, "\nPlayer %c has won after %d moves\n",
		 winner, b_move_counter (thegame->boards[0]));

	b_del (thegame->boards[0]);
	(* players[player[0].playertype].endfunc)(player[0].self);
	(* players[player[1].playertype].endfunc)(player[1].self);
	thegame->boards[0] = NULL;
	game_type = -1;
	fclose (GIPFLOG);
	GIPFLOG = NULL;
	SetString (lblplayer, "No game in progress.");
	SetValue (btnmove, 1, Hidden);
d508 1
d513 1
a513 1
void gipfCmdWindow::computermove (void)
a522 1
    vNoticeDialog note(this);
d525 4
a528 4
    temp_board = b_copy (main_board);
    nextpiece = b_next_piece (main_board);
    piecetype = b_colour_type (main_board, nextpiece);
    playertype = player[pnr(nextpiece)].playertype;
d531 1
a531 1
	(temp_board, player[pnr(nextpiece)].self, &piecetype,
d534 1
a534 1
    if ((b_colour_type (main_board, nextpiece) != 'g') &&
d540 1
a540 1
    if (waitcomputer > 0)
d544 1
a544 1
	gipfCanvas->setfrom (temppos);
d547 1
a547 1
	gipfCanvas->setto (temppos);
d550 1
a550 1
	    gipfCanvas->setgipfpossible (1);
d552 1
a552 1
	    gipfCanvas->setgipfpossible (0);
d554 2
a555 2
	gipfCanvas->changeboard (main_board);
	theApp->CheckEvents ();
d558 1
a558 1
	sleep (waitcomputer * 1000);
d560 1
a560 1
	usleep (waitcomputer * 1000000L);
d563 2
a564 2
	gipfCanvas->setfrom (NULL);
	gipfCanvas->setto (NULL);
d566 9
a574 6
	// only do this if no animation
	if (animate == 0)
	{
	    gipfCanvas->changeboard (main_board);
	    theApp->CheckEvents ();
	}
d579 3
a581 3
    setremovewait (main_board, 1);
    setanimate (main_board, 1);
    new_board = b_move (main_board, from, to, piece);
d586 1
a586 1
	note.Notice("the computer-player executed an invalid move !!");
d588 4
a591 4
	b_del (main_board);
	(* players[player[0].playertype].endfunc)(player[0].self);
	(* players[player[1].playertype].endfunc)(player[1].self);
	main_board = NULL;
d595 7
a601 5
	b_del (main_board);
	main_board = new_board;
	setremovewait (main_board, 0);
	setanimate (main_board, 0);
	gipfCanvas->changeboard (main_board);
d608 1
a608 1
int gipfCmdWindow::humanmove (char * from, char * to, char piecetype)
d614 10
d625 2
a626 2
    nextpiece = b_next_piece (main_board);
    playertype = player[pnr(nextpiece)].playertype;
d628 1
a628 1
    if ((b_colour_type (main_board, nextpiece) != 'g') &&
d636 6
a641 3
    setremovewait (main_board, 1);
    setanimate (main_board, 1);
    new_board = b_move (main_board, from, to, piece);
d645 2
a646 2
	setremovewait (main_board, 0);
	setanimate (main_board, 0);
d650 10
a659 8
    b_del (main_board);
    main_board = new_board;
    setremovewait (main_board, 0);
    setanimate (main_board, 0);

    gipfCanvas->setto (NULL);
    gipfCanvas->setfrom (NULL);
    gipfCanvas->changeboard (main_board);
d665 1
a665 1
void gipfCmdWindow::row_questions (void)
d676 2
a677 2
	tempstr[100];
    vYNReplyDialog ynd (this);
d680 1
a680 1
    temp_board = b_copy (main_board);
d682 1
a682 1
    rowlist = b_row_extra (main_board);
d690 1
a690 1
	if (player[pnr(owner)].playertype == 0)
d692 7
a698 2
	    gipfCanvas->setrow (row);
	    gipfCanvas->changeboard (main_board);
a699 8
	    sprintf (tempstr, 
		     "Player %s,\ndo you want to remove the row from %s to %s",
		     player[pnr(owner)].name, start, end);
	    answer = -1;
	    while (answer == -1)
	    {
		answer = ynd.AskYN (tempstr);
	    }
d705 1
a705 1
	    gipfCanvas->setrow (NULL);
d709 6
a714 5
	    computerthinking = 1;
	    response = (* players[player[pnr(owner)].playertype].rowfunc)
		(temp_board, player[pnr(owner)].self, start, end);
	    computerthinking = 0;
	    setremovewait (main_board, 1);
d722 4
a725 4
	    new_board = b_remove_row (main_board, counter-1);
	    b_del (main_board);
	    main_board = new_board;
	    gipfCanvas->changeboard (main_board);
d727 1
a727 1
	    setremovewait (main_board, 0);
d730 1
a730 1
	setremovewait (main_board, 0);
d738 1
a738 1
void gipfCmdWindow::gipf_questions (void)
d749 2
a750 2
    char tempstr[100];
    vYNReplyDialog ynd (this);
d754 3
a756 2
    gipflist = b_gipf_extra (main_board);
    new_board = main_board;
d763 1
a763 1
	if (player[pnr(owner)].playertype == 0)
d765 2
a766 2
	    gipfCanvas->setto (gipf->pos);
	    gipfCanvas->changeboard (new_board);
d768 4
a771 8
	    sprintf (tempstr, 
		     "Player %s,\n do you want to remove the GIPF at %s",
		     player[pnr(owner)].name, strpos);
	    answer = -1;
	    while (answer == -1)
	    {
		answer = ynd.AskYN (tempstr);
	    }
d778 1
a778 1
	    gipfCanvas->setto (NULL);
d783 4
a786 4
	    computerthinking = 1;
	    response = (* players[player[pnr(owner)].playertype].gipffunc)
		(temp_board, player[pnr(owner)].self, strpos);
	    computerthinking = 0;
d788 1
a788 1
	    setremovewait (new_board, 1);
d794 1
a794 1
	    if (new_board != main_board)
d798 1
a798 1
	    gipfCanvas->changeboard (new_board);
d801 1
a801 1
	setremovewait (new_board, 0);
d805 1
a805 1
    if (new_board != main_board)
d808 2
a809 2
    b_del (main_board);
    main_board = nboard;
d811 1
a811 1
    gipfCanvas->changeboard (main_board);
@


1.7
log
@savegame now shows a default filename
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.6 1998/09/29 18:03:14 kurt Exp kurt $
d390 420
@


1.6
log
@some small changes
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.5 1998/09/28 18:29:02 kurt Exp kurt $
d350 2
a351 1
    if ((filename = fl_file_chooser ("save game", "*.gf1", NULL)) == NULL)
@


1.5
log
@added the function-calls to initialize the players.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.4 1998/09/27 19:19:04 kurt Exp kurt $
d232 1
a232 1
    if ((filename = fl_file_chooser ("save game", "*.gf1", NULL)) == NULL)
@


1.4
log
@show_new: creates the first gameboard now also
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.3 1998/09/27 18:40:17 kurt Exp kurt $
d15 1
d36 1
d162 7
a168 2
		newgame->player[0].self = NULL;
		newgame->player[1].self = NULL;
d196 1
a196 1
    /* ask the player to cleanup its data (only form computerplayer) */
d199 1
d203 1
d324 5
a328 1
// reading was succesfull, init the players
@


1.3
log
@added savegame and loadgame
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.2 1998/09/24 17:43:43 kurt Exp kurt $
d156 1
a156 1
		newgame->boards[0] = NULL;
@


1.2
log
@show_new can now be setup using a previous game.
@
text
@d2 1
a2 1
** $Id: thegame.cxx,v 1.1 1998/09/22 19:19:42 kurt Exp kurt $
d8 2
d13 2
d160 3
d179 199
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
** $Id$
d33 40
d81 2
d132 4
a135 2
		    newgame->player[0].timer = (int) whitetime->value();
		    newgame->player[1].timer = (int) blacktime->value();
d139 4
a142 2
		    newgame->player[0].timer = -1;
		    newgame->player[1].timer = -1;
@
